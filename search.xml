<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>File类</title>
      <link href="/2021/11/14/File%E7%B1%BB/"/>
      <url>/2021/11/14/File%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h1><ol><li><p>File类和IO流四大家族没有关系，所以File类不能完成文件的读和写。</p></li><li><p>File对象代表什么？文件和目录路径名的抽象表示形式。</p><pre><code> C:\Drivers 这是一个File对象</code></pre></li></ol><p>​        C:\Drivers\Lan\Realtek\Readme.txt 也是File对象。</p><p>​        一个File对象有可能对应的是目录，也可能是文件。</p><p>​        File只是一个路径名的抽象表示形式。</p><ol><li>需要掌握File类中常用的方法</li></ol><h2 id="常用方法："><a href="#常用方法：" class="headerlink" title="常用方法："></a>常用方法：</h2><p><code>File(String pathname)</code>: 构造方法，通过将给定路径名字符串转换为抽象路径名来创建一个新 <code>File</code> 实例。如果给定字符串是空字符串，那么结果是空抽象路径名。</p><p>​    抛出：<code>NullPointerException</code> - 如果 pathname 参数为 null</p><p><code>boolean createNewFile()</code>: 当且仅当不存在具有此抽象路径名指定名称的文件时，不可分地创建一个新的空文件。检查文件是否存在，若不存在则创建该文件，这                                            是单个操作，对于其他所有可能影响该文件的文件系统活动来说，该操作是不可分的。</p><p>​    返回：如果指定的文件不存在并成功地创建，则返回 <code>true</code>；如果指定的文件已经存在，则返回 <code>false</code></p><p>​    抛出：</p><p>​        <code>IOException</code> - 如果发生 I/O 错误</p><p>​        <code>SecurityException</code> - 如果存在安全管理器，且其 <code>SecurityManager.checkWrite(java.lang.String)</code> 方法拒绝对文件进行写访问</p><p><code>boolean delete()</code>: 删除此抽象路径名表示的文件或目录。如果此路径名表示一个目录，则该目录必须为空才能删除。当且仅当成功删除文件或目录时，返回                                 <code>true</code>；否则返回 <code>false</code></p><p>​    抛出：<code>SecurityException</code> - 如果存在安全管理器，且其 <code>SecurityManager.checkDelete(java.lang.String)</code> 方法拒绝对文件进行删除访问</p><p><code>boolean exists()</code>: 测试此抽象路径名表示的文件或目录是否存在。当且仅当此抽象路径名表示的文件或目录存在时，返回 <code>true</code>；否则返回 <code>false</code></p><p>​    抛出：<code>SecurityException</code> - 如果存在安全管理器，且其 <code>SecurityManager.checkRead(java.lang.String)</code> 方法拒绝对文件或目录进行写访问</p><p><code>String getParent()</code>： 返回此抽象路径名父目录的路径名字符串；如果此路径名没有指定父目录，则返回 <code>null</code>。</p><p><code>String getPath()</code>： 将此抽象路径名转换为一个路径名字符串。所得字符串使用 <a href="https://tool.oschina.net/uploads/apidocs/jdk-zh/java/io/File.html#separator"><code>默认名称分隔符</code></a>分隔名称序列中的名称。</p><p><code>File getParentFile()</code>： 返回此抽象路径名父目录的抽象路径名；如果此路径名没有指定父目录，则返回 <code>null</code>。</p><p>​        抽象路径名的<em>父</em> 路径名由路径名的前缀（如果有），以及路径名名称序列中最后一个名称以外的所有名称组成。如果名称序列为空，那么该路径名没有指定        父目录。</p><p><code>getAbsolutePath</code>： 返回此抽象路径名的绝对路径名字符串。</p><p>​    如果此抽象路径名已经是绝对路径名，则返回该路径名字符串，这与 <code>getPath()</code> 方法一样。如果此抽象路径名是空抽象路径名，则返回当前用户目录的路径名    字符串，该目录由系统属性 <code>user.dir</code> 指定。否则，使用与系统有关的方式解析此路径名。在 UNIX 系统上，根据当前用户目录解析相对路径名，可使该路径名    成为绝对路径名。在 Microsoft Windows 系统上，根据路径名指定的当前驱动器目录（如果有）解析相对路径名，可使该路径名成为绝对路径名；否则，可以根    据当前用户目录解析它。</p><p>​    抛出：<code>SecurityException</code> - 如果无法访问所需的系统属性值。</p><p><code>boolean mkdir()</code>: 创建此抽象路径名指定的目录。当且仅当已创建目录时，返回 <code>true</code>；否则返回 <code>false</code></p><p>​    抛出：<code>SecurityException</code> - 如果存在安全管理器，且其 <code>SecurityManager.checkWrite(java.lang.String)</code> 方法不允许创建指定的目录</p><p><code>boolean mkdirs()</code>: 创建此抽象路径名指定的目录，包括所有必需但不存在的父目录。注意，此操作失败时也可能已经成功地创建了一部分必需的父目录。当且仅                                当已创建目录以及所有必需的父目录时，返回 <code>true</code>；否则返回 <code>false</code></p><p>抛出：<code>SecurityException</code> - 如果存在安全管理器，且其 <code>SecurityManager.checkRead(java.lang.String)</code> 方法不允许验证指定目录和所有必需的父目录是否存            在；或者 <code>SecurityManager.checkWrite(java.lang.String)</code> 方法不允许创建指定的目录和所有必需的父目录</p><p><code>boolean renameTo(File dest)</code>: 重新命名此抽象路径名表示的文件。</p><p>​    抛出：<code>SecurityException</code> - 如果存在安全管理器，且其 <code>SecurityManager.checkWrite(java.lang.String)</code> 方法拒绝对原路径名和新路径名进行写访问                        <code>NullPointerException`` - 如果参数</code>dest<code>为</code>null</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.bjpowernode.java.io;import java.io.File;public class FileTest01 {    public static void main(String[] args) throws Exception {        // 创建一个File对象        File f1 = new File("D:\\file");        // 判断是否存在！        System.out.println(f1.exists());        // 如果D:\file不存在，则以文件的形式创建出来        /*if(!f1.exists()) {            // 以文件形式新建            f1.createNewFile();        }*/        // 如果D:\file不存在，则以目录的形式创建出来        /*if(!f1.exists()) {            // 以目录的形式新建。            f1.mkdir();        }*/        // 可以创建多重目录吗？        File f2 = new File("D:/a/b/c/d/e/f");        /*if(!f2.exists()) {            // 多重目录的形式新建。            f2.mkdirs();        }*/        File f3 = new File("D:\\course\\01-开课\\学习方法.txt");        // 获取文件的父路径        String parentPath = f3.getParent();        System.out.println(parentPath); //D:\course\01-开课        File parentFile = f3.getParentFile();        System.out.println("获取绝对路径：" + parentFile.getAbsolutePath());        File f4 = new File("copy");        System.out.println("绝对路径：" + f4.getAbsolutePath()); // C:\Users\Administrator\IdeaProjects\javase\copy    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>String getName()</code>: 返回由此抽象路径名表示的文件或目录的名称。该名称是路径名名称序列中的最后一个名称。如果路径名名称序列为空，则返回空字符串。</p><p><code>boolean isDirectory()</code>:  测试此抽象路径名表示的文件是否是一个目录。当且仅当此抽象路径名表示的文件存在 <em>且</em> 是一个目录时，返回 <code>true</code>；否则返回                                         <code>false</code></p><p>​    抛出：<code>SecurityException</code> - 如果存在安全管理器，且其 <code>SecurityManager.checkRead(java.lang.String)</code> 方法拒绝对文件进行读访问</p><p><code>boolean isFile()</code>: 测试此抽象路径名表示的文件是否是一个标准文件。如果该文件不是一个目录，并且满足其他与系统有关的标准，那么该文件是 <em>标准</em> 文件。                                由 Java 应用程序创建的所有非目录文件一定是标准文件。当且仅当此抽象路径名表示的文件存在 <em>且</em> 是一个标准文件时，返回 <code>true</code>；否则返                                回 <code>false</code></p><p>​    抛出：<code>SecurityException</code> - 如果存在安全管理器，且其 <code>SecurityManager.checkRead(java.lang.String)</code> 方法拒绝对文件进行读访问</p><p><code>boolean isHidden()</code>: 当且仅当此抽象路径名表示的文件根据底层平台约定是隐藏文件时，返回 <code>true</code></p><p>​    抛出：<code>SecurityException</code> - 如果存在安全管理器，且其 <code>SecurityManager.checkRead(java.lang.String)</code> 方法拒绝对文件进行读访问</p><p><code>long lastModified()</code>: 返回此抽象路径名表示的文件最后一次被修改的时间。用与时间点（1970 年 1 月 1 日，00:00:00 GMT）之间的毫秒数表示；如果该文件                                    不存在，或者发生 I/O 错误，则返回 <code>0L</code></p><p>​    抛出：<code>SecurityException</code> - 如果存在安全管理器，且其 <code>SecurityManager.checkRead(java.lang.String)</code> 方法拒绝对文件进行读访问</p><p><code>long length()</code>: 此抽象路径名表示的文件的长度，以字节为单位；如果文件不存在，则返回 <code>0L</code>。对于表示特定于系统的实体（比如设备或管道）的路径名，某                            些操作系统可能返回 <code>0L</code>。如果此路径名表示一个目录，则返回值是不确定的。</p><p>​    抛出：<code>SecurityException</code> - 如果存在安全管理器，且其 <code>SecurityManager.checkRead(java.lang.String)</code> 方法拒绝对文件进行读访问</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.bjpowernode.java.io;import java.io.File;import java.text.SimpleDateFormat;import java.util.Date;public class FileTest02 {    public static void main(String[] args) {        File f1 = new File("D:\\course\\01-开课\\开学典礼.ppt");        // 获取文件名        System.out.println("文件名：" + f1.getName());        // 判断是否是一个目录        System.out.println(f1.isDirectory()); // false        // 判断是否是一个文件        System.out.println(f1.isFile()); // true        // 获取文件最后一次修改时间        long haoMiao = f1.lastModified(); // 这个毫秒是从1970年到现在的总毫秒数。        // 将总毫秒数转换成日期?????        Date time = new Date(haoMiao);        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss SSS");        String strTime = sdf.format(time);        System.out.println(strTime);        // 获取文件大小        System.out.println(f1.length()); //216064字节。    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>File[] listFiles()</code>: 获取当前目录下所有的子文件。返回一个抽象路径名数组，这些路径名表示此抽象路径名表示的目录中的文件。</p><p>​    抛出：<code>SecurityException</code> - 如果存在安全管理器，且其 <code>SecurityManager.checkRead(java.lang.String)</code> 方法拒绝对目录进行读访问</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.bjpowernode.java.io;import java.io.File;/*File中的listFiles方法。 */public class FileTest03 {    public static void main(String[] args) {        // File[] listFiles()        // 获取当前目录下所有的子文件。        File f = new File("D:\\course\\01-开课");        File[] files = f.listFiles();        // foreach        for(File file : files){            //System.out.println(file.getAbsolutePath());            System.out.println(file.getName());        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> File文件类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IO流</title>
      <link href="/2021/11/13/IO%E6%B5%81/"/>
      <url>/2021/11/13/IO%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<h1 id="IO流概述"><a href="#IO流概述" class="headerlink" title="IO流概述"></a>IO流概述</h1><p><strong><em>IO流，什么是IO？</em></strong></p><p>​    I : Input ；  O : Output</p><p>通过IO可以完成硬盘文件的读和写。</p><h3 id="IO流的分类？"><a href="#IO流的分类？" class="headerlink" title="IO流的分类？"></a>IO流的分类？</h3><p>有多种分类方式：</p><p>​    一种方式是按照流的方向进行分类：</p><p>​        以内存作为参照物，</p><p>​            往内存中去，叫做输入(Input)。或者叫做读(Read)。</p><p>​            从内存中出来，叫做输出(Output)。或者叫做写(Write)。</p><p>​        另一种方式是按照读取数据方式不同进行分类：<br>​          有的流是按照字节的方式读取数据，一次读取1个字节byte，等同于一次读取8个二进制位。这种流是万能的，什么类型的文件都可以读取。包括：文本文件，图片，声音文件，视频文件等….<br>​                假设文件file1.txt，采用字节流的话是这样读的：<br>​                  a中国bc张三fe<br>​                  第一次读：一个字节，正好读到’a’<br>​                  第二次读：一个字节，正好读到’中’字符的一半。<br>​                  第三次读：一个字节，正好读到’中’字符的另外一半。</p><p>​            有的流是按照字符的方式读取数据的，一次读取一个字符，这种流是为了方便读取普通文本文件而存在的，这种流不能读取：图片、声音、视频等文件。只能读取纯文本文件，连word文件都无法读取。<br>​                假设文件file1.txt，采用字符流的话是这样读的：<br>​                  a中国bc张三fe<br>​                  第一次读：’a’字符（’a’字符在windows系统中占用1个字节。）<br>​                  第二次读：’中’字符（’中’字符在windows系统中占用2个字节。）</p><blockquote><p>综上所述：流的分类<br>    输入流、输出流<br>    字节流、字符流</p></blockquote><h3 id="java-IO流这块有四大家族："><a href="#java-IO流这块有四大家族：" class="headerlink" title="java IO流这块有四大家族："></a>java IO流这块有四大家族：</h3><p><em>四大家族的首领：</em></p><p>​    <code>java.io.InputStream</code> 字节输入流</p><p>​    <code>java.io.OutputStream</code> 字节输出流</p><p>​    <code>java.io.Reader</code>   字符输入流</p><p>​    <code>java.io.Writer</code>   字符输出流</p><p>四大家族的首领都是抽象类。(abstract class)</p><p><em>所有的流都实现了：</em></p><p>​    java.io.Closeable接口，都是可关闭的，都有close()方法。</p><p>​    流毕竟是一个管道，这个是内存和硬盘之间的通道，用完之后一定要关闭，不然会耗费(占用)很多资源。养成好习惯，用完流一定要关闭。</p><p><em>所有的输出流都实现了：</em></p><p>​    java.io.Flushable接口，都是可刷新的，都有flush()方法。</p><p>​    养成一个好习惯，输出流在最终输出之后，一定要记得flush()刷新一下。这个刷新表示将通道/管道当中剩余未输出的数据,强行输出完（清空管道！）刷新的作用就是清空管道。</p><p>​    <strong>注意：如果没有flush()可能会导致丢失数据。</strong></p><blockquote><p>注意：在java中只要“类名”以Stream结尾的都是字节流。以“Reader/Writer”结尾的都是字符流。</p></blockquote><h3 id="java-io包下需要掌握的流有16个"><a href="#java-io包下需要掌握的流有16个" class="headerlink" title="java.io包下需要掌握的流有16个"></a>java.io包下需要掌握的流有16个</h3><p>  <em>文件专属：</em></p><p>​        <code>java.io.FileInputStream</code>（掌握）</p><p>​        <code>java.io.FileOutputStream</code>（掌握）</p><p>​        <code>java.io.FileReader</code></p><p>​        <code>java.io.FileWriter</code></p><p>  <em>转换流：（将字节流转换成字符流）</em></p><p>​        <code>java.io.InputStreamReader</code></p><p>​        <code>java.io.OutputStreamWriter</code></p><p>  <em>缓冲流专属：</em></p><p>​        <code>java.io.BufferedReader</code></p><p>​        <code>java.io.BufferedWriter</code></p><p>​        <code>java.io.BufferedInputStream</code></p><p>​        <code>java.io.BufferedOutputStream</code></p><p>  <em>数据流专属：</em></p><p>​        <code>java.io.DataInputStream</code></p><p>​        <code>java.io.DataOutputStream</code></p><p>  <em>标准输出流：</em></p><pre><code>    `java.io~.PrintWriter`</code></pre><p>​        <code>java.io.PrintStream</code>（掌握）</p><p>  <em>对象专属流：</em></p><p>​        <code>java.io.ObjectInputStream</code>（掌握）</p><p>​        <code>java.io.ObjectOutputStream</code>（掌握）</p><h1 id="文件流"><a href="#文件流" class="headerlink" title="文件流"></a>文件流</h1><h2 id="FileInputStream"><a href="#FileInputStream" class="headerlink" title="FileInputStream"></a>FileInputStream</h2><p>java.io.FileInputStream:</p><ol><li><p>文件字节输入流，万能的，任何类型的文件都可以采用这个流来读。</p></li><li><p>字节的方式，完成输入的操作，完成读的操作（硬盘—-&gt; 内存）</p></li></ol><h3 id="常用方法："><a href="#常用方法：" class="headerlink" title="常用方法："></a>常用方法：</h3><p><code>FileInputStream(File file)</code> : 构造方法，通过打开与File类对象代表的实际文件的链接来创建FileInputStream流对象。<code>file</code> - 为了进行读取而打开的文件。</p><p>​    抛出异常：</p><p>​        <code>FileNotFoundException</code> - 如果该文件不存在，或者它是一个目录，而不是一个常规文件，抑或因为其他某些原因而无法打开进行读取。</p><p>​        <code>SecurityException</code> - 如果存在安全管理器，且其 <code>checkRead</code> 方法拒绝对文件进行读取访问。</p><p><code>void close()</code>：关闭此文件输入流并释放与此流有关的所有系统资源。如果此流有一个与之关联的通道，则关闭该通道。</p><p>​    抛出：<code>IOException</code> - 如果发生 I/O 错误。</p><p><code>int read()</code>: 从此输入流中读取一个数据字节。如果没有输入可用，则此方法将阻塞。</p><p>​    返回：下一个数据字节;如果已到达文件末尾，则返回-1。</p><p>​    抛出：<code>IOException</code> - 如果发生 I/O 错误。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.bjpowernode.java.io;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.IOException;public class FileInputStreamTest02 {    public static void main(String[] args) {        FileInputStream fis = null;        try {            fis = new FileInputStream("D:\\course\\JavaProjects\\02-JavaSE\\temp");            /*while(true) {                int readData = fis.read();                if(readData == -1) {                    break;                }                System.out.println(readData);            }*/            // 改造while循环            int readData = 0;            while((readData = fis.read()) != -1){                System.out.println(readData);            }        } catch (FileNotFoundException e) {            e.printStackTrace();        } catch (IOException e) {            e.printStackTrace();        } finally {            if (fis != null) {                try {                    fis.close();                } catch (IOException e) {                    e.printStackTrace();                }            }        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>分析这个程序的缺点：<br>    一次读取一个字节byte，这样内存和硬盘交互太频繁，基本上时间/资源都耗费<br>    在交互上面了。能不能一次读取多个字节呢？可以。</p></blockquote><p><code>int read(byte[] b)</code>:从此输入流中将最多 <code>b.length</code> 个字节的数据读入一个 byte 数组中。在某些输入可用之前，此方法将阻塞。</p><pre><code> 返回：读入缓冲区的字节总数，如果因为已经到达文件末尾而没有更多的数据，则返回 `-1`。 抛出：`IOException` - 如果发生 I/O 错误。</code></pre><p>一次最多读取 b.length 个字节。减少硬盘和内存的交互，提高程序的执行效率。往byte[]数组当中读。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.bjpowernode.java.io;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.IOException;public class FileInputStreamTest03 {    public static void main(String[] args) {        FileInputStream fis = null;        try {            fis = new FileInputStream("chapter23/src/com/bjpowernode/java/io/tempfile4");            // 开始读，采用byte数组，一次读取多个字节。最多读取“数组.length”个字节。            byte[] bytes = new byte[4]; // 准备一个4个长度的byte数组，一次最多读取4个字节。            // 这个方法的返回值是：读取到的字节数量。（不是字节本身）            int readCount = fis.read(bytes);            System.out.println(readCount); // 第一次读到了4个字节。            // 将字节数组全部转换成字符串            //System.out.println(new String(bytes)); // abcd            // 不应该全部都转换，应该是读取了多少个字节，转换多少个。            System.out.println(new String(bytes,0, readCount));            readCount = fis.read(bytes); // 第二次只能读取到2个字节。            System.out.println(readCount); // 2            // 将字节数组全部转换成字符串            //System.out.println(new String(bytes)); // efcd            // 不应该全部都转换，应该是读取了多少个字节，转换多少个。            System.out.println(new String(bytes,0, readCount));            readCount = fis.read(bytes); // 1个字节都没有读取到返回-1            System.out.println(readCount); // -1        } catch (FileNotFoundException e) {            e.printStackTrace();        } catch (IOException e) {            e.printStackTrace();        } finally {            if (fis != null) {                try {                    fis.close();                } catch (IOException e) {                    e.printStackTrace();                }            }        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>int available()</code>： 返回下一次对此输入流调用的方法可以不受阻塞地从此输入流读取（或跳过）的估计剩余字节数。下一次调用可能是同一个线程，也可能是另                                一个线程。一次读取或跳过此数量个字节不会发生阻塞，但读取或跳过的字节可能小于该数。</p><p>​        在某些情况下，非阻塞的读取（或跳过）操作在执行很慢时看起来受阻塞，例如，在网速缓慢的网络上读取大文件时。</p><p>​    抛出：<code>IOException</code> - 如果此文件输入流已通过调用 <code>close</code> 关闭，或者发生 I/O 错误。</p><p><code>long skip(long n)</code>： 从输入流中跳过并丢弃 <code>n</code> 个字节的数据。</p><p>​    参数：<code>n</code> - 要跳过的字节数。</p><p>​    返回：实际跳过的字节数。</p><p>​    抛出：<code>IOException</code> - 如果 n 为负，如果该流不支持查找操作，或者发生 I/O 错误。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.bjpowernode.java.io;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.IOException;/*FileInputStream类的其它常用方法：    int available()：返回流当中剩余的没有读到的字节数量    long skip(long n)：跳过几个字节不读。 */public class FileInputStreamTest05 {    public static void main(String[] args) {        FileInputStream fis = null;        try {            fis = new FileInputStream("tempfile");            System.out.println("总字节数量：" + fis.available());            // 读1个字节            //int readByte = fis.read();            // 还剩下可以读的字节数量是：5            //System.out.println("剩下多少个字节没有读：" + fis.available());            // 这个方法有什么用？            //byte[] bytes = new byte[fis.available()]; // 这种方式不太适合太大的文件，因为byte[]数组不能太大。            // 不需要循环了。            // 直接读一次就行了。            //int readCount = fis.read(bytes); // 6            //System.out.println(new String(bytes)); // abcdef            // skip跳过几个字节不读取，这个方法也可能以后会用！            fis.skip(3);            System.out.println(fis.read()); //100        } catch (FileNotFoundException e) {            e.printStackTrace();        } catch (IOException e) {            e.printStackTrace();        } finally {            if (fis != null) {                try {                    fis.close();                } catch (IOException e) {                    e.printStackTrace();                }            }        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="FileOutputStream"><a href="#FileOutputStream" class="headerlink" title="FileOutputStream"></a>FileOutputStream</h2><p>文件字节输出流，负责写。从内存到硬盘。</p><h3 id="常用方法：-1"><a href="#常用方法：-1" class="headerlink" title="常用方法："></a>常用方法：</h3><p><code>FileOutputStream(File file)</code>：构造方法，创建一个向指定 <code>File</code> 对象表示的文件中写入数据的文件输出流。创建一个新 <code>FileDescriptor</code> 对象来表示此文件连                                                    接。</p><p>​    抛出：</p><p>​        <code>FileNotFoundException</code> - 如果该文件存在，但它是一个目录，而不是一个常规文件；或者该文件不存在，但无法创建它；抑或因为其他某些原因而无法打开</p><p>​        <code>SecurityException</code> - 如果存在安全管理器，且其 <code>checkWrite</code> 方法拒绝对文件进行写入访问。</p><p><code>FileOutputStream(String name, boolean append)</code>： 构造方法，创建一个向具有指定 <code>name</code> 的文件中写入数据的输出文件流。如果第二个参数为 <code>true</code>，则将字                                                                                    节写入文件末尾处，而不是写入文件开始处。创建一个新 <code>FileDescriptor</code> 对象来表示此文件连接。</p><p>​    参数：</p><p>​        <code>name</code> - 与系统有关的文件名</p><p>​        <code>append</code> - 如果为 <code>true</code>，则将字节写入文件末尾处，而不是写入文件开始处</p><p>​    抛出：</p><p>​        <code>FileNotFoundException</code> - 如果该文件存在，但它是一个目录，而不是一个常规文件；或者该文件不存在，但无法创建它；抑或因为其他某些原因而无法打开</p><p>​        <code>SecurityException</code> - 如果存在安全管理器，且其 <code>checkWrite</code> 方法拒绝对文件进行写入访问。</p><p><code>void close()</code>： 关闭此文件输出流并释放与此流有关的所有系统资源。此文件输出流不能再用于写入字节。</p><p>​    抛出：<code>IOException</code> - 如果发生 I/O 错误。</p><p><code>void write(byte[] b)</code>：将 <code>b.length</code> 个字节从指定 byte 数组写入此文件输出流中。</p><p>​    抛出：<code>IOException</code> - 如果发生 I/O 错误。</p><p><code>void write(byte[] b,int off,int len)</code>： 将指定 byte 数组中从偏移量 <code>off</code> 开始的 <code>len</code> 个字节写入此文件输出流。</p><p>​    参数：</p><p>​            <code>b</code> - 数据。</p><pre><code>         `off` - 数据中的起始偏移量。</code></pre><p>​            <code>len</code> - 要写入的字节数。</p><p>​    抛出：<code>IOException</code> - 如果发生 I/O 错误。</p><p><code>void flush()</code>： 刷新此输出流并强制写出所有缓冲的输出字节。</p><p>​    抛出：<code>IOException</code> - 如果发生 I/O 错误。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.bjpowernode.java.io;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;public class FileOutputStreamTest01 {    public static void main(String[] args) {        FileOutputStream fos = null;        try {            // myfile文件不存在的时候会自动新建！            // 这种方式谨慎使用，这种方式会先将原文件清空，然后重新写入。            //fos = new FileOutputStream("myfile");            //fos = new FileOutputStream("chapter23/src/tempfile3");            // 以追加的方式在文件末尾写入。不会清空原文件内容。            fos = new FileOutputStream("chapter23/src/tempfile3", true);            // 开始写。            byte[] bytes = {97, 98, 99, 100};            // 将byte数组全部写出！            fos.write(bytes); // abcd            // 将byte数组的一部分写出！            fos.write(bytes, 0, 2); // 再写出ab            // 字符串            String s = "我是一个中国人，我骄傲！！！";            // 将字符串转换成byte数组。            byte[] bs = s.getBytes();            // 写            fos.write(bs);            // 写完之后，最后一定要刷新            fos.flush();        } catch (FileNotFoundException e) {            e.printStackTrace();        } catch (IOException e) {            e.printStackTrace();        } finally {            if (fos != null) {                try {                    fos.close();                } catch (IOException e) {                    e.printStackTrace();                }            }        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="文件复制"><a href="#文件复制" class="headerlink" title="文件复制"></a>文件复制</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.bjpowernode.java.io;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;/*使用FileInputStream + FileOutputStream完成文件的拷贝。拷贝的过程应该是一边读，一边写。使用以上的字节流拷贝文件的时候，文件类型随意，万能的。什么样的文件都能拷贝。 */public class Copy01 {    public static void main(String[] args) {        FileInputStream fis = null;        FileOutputStream fos = null;        try {            // 创建一个输入流对象            fis = new FileInputStream("D:\\course\\02-JavaSE\\video\\chapter01\\动力节点-JavaSE-杜聚宾-001-文件扩展名的显示.avi");            // 创建一个输出流对象            fos = new FileOutputStream("C:\\动力节点-JavaSE-杜聚宾-001-文件扩展名的显示.avi");            // 最核心的：一边读，一边写            byte[] bytes = new byte[1024 * 1024]; // 1MB（一次最多拷贝1MB。）            int readCount = 0;            while((readCount = fis.read(bytes)) != -1) {                fos.write(bytes, 0, readCount);            }            // 刷新，输出流最后要刷新            fos.flush();        } catch (FileNotFoundException e) {            e.printStackTrace();        } catch (IOException e) {            e.printStackTrace();        } finally {            // 分开try，不要一起try。            // 一起try的时候，其中一个出现异常，可能会影响到另一个流的关闭。            if (fos != null) {                try {                    fos.close();                } catch (IOException e) {                    e.printStackTrace();                }            }            if (fis != null) {                try {                    fis.close();                } catch (IOException e) {                    e.printStackTrace();                }            }        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="FileReader"><a href="#FileReader" class="headerlink" title="FileReader"></a>FileReader</h2><p>文件字符输入流，只能读取普通文本。读取文本内容时，比较方便，快捷。</p><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><p><code>FileReader(String fileName)</code>：构造方法， 在给定从中读取数据的文件名的情况下创建一个新 <code>FileReader</code>。</p><p>​    抛出：<code>FileNotFoundException</code> - 如果指定文件不存在，或者它是一个目录，而不是一个常规文件，抑或因为其他某些原因而无法打开进行读取。</p><p><code>int read()</code>：读取单个字符。</p><p>​    返回：读取的字符，如果已到达流的末尾，则返回 -1</p><p>​    抛出：<code>IOException</code> - 如果发生 I/O 错误</p><p><code>int read(char[] cbuf）</code>：来自父类<code>Reader</code>，将字符读入数组</p><p>​     返回：读取的字符数，如果已到达流的末尾，则返回 -1</p><p>​    抛出：<code>IOException</code> - 如果发生 I/O 错误</p><p><code>int read(char[] cbuf,int offset,int length)</code>： 将字符读入数组中的某一部分</p><p>​    参数：</p><p>​        <code>cbuf</code> - 目标缓冲区</p><p>​        <code>offset</code> - 从其处开始存储字符的偏移量</p><p>​        <code>length</code> - 要读取的最大字符数</p><p>​    返回：读取的字符数，如果已到达流的末尾，则返回 -1</p><p>​    抛出：<code>IOException</code> - 如果发生 I/O 错误</p><p><code>long skip(long n)</code>： 跳过字符。在某个字符可用、发生 I/O 错误或者已到达流的末尾前，此方法一直阻塞。</p><p>​    参数：<code>n</code> - 要跳过的字符数</p><p>​    返回：实际跳过的字符数</p><p>​    抛出：</p><p>​        <code>IllegalArgumentException</code> - 如果 <code>n</code> 为负。</p><p>​        <code>IOException</code> - 如果发生 I/O 错误</p><p><code>void close()</code>： 关闭该流并释放与之关联的所有资源。在关闭该流后，再调用 read()、ready()、mark()、reset() 或 skip() 将抛出 IOException。关闭以前关闭的                            流无效。</p><p>​    抛出：<code>IOException</code> - 如果发生 I/O 错误</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.bjpowernode.java.io;import java.io.FileNotFoundException;import java.io.FileReader;import java.io.IOException;public class FileReaderTest {    public static void main(String[] args) {        FileReader reader = null;        try {            // 创建文件字符输入流            reader = new FileReader("tempfile");            //准备一个char数组            char[] chars = new char[4];            // 往char数组中读            reader.read(chars); // 按照字符的方式读取：第一次e，第二次f，第三次 风....            for(char c : chars) {                System.out.println(c);            }            /*// 开始读            char[] chars = new char[4]; // 一次读取4个字符            int readCount = 0;            while((readCount = reader.read(chars)) != -1) {                System.out.print(new String(chars,0,readCount));            }*/        } catch (FileNotFoundException e) {            e.printStackTrace();        } catch (IOException e) {            e.printStackTrace();        } finally {            if (reader != null) {                try {                    reader.close();                } catch (IOException e) {                    e.printStackTrace();                }            }        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="FileWriter"><a href="#FileWriter" class="headerlink" title="FileWriter"></a>FileWriter</h2><p>文件字符输出流。写。只能输出普通文本。</p><h3 id="常用方法：-2"><a href="#常用方法：-2" class="headerlink" title="常用方法："></a>常用方法：</h3><p><code>FileWriter(File file)</code>：构造方法，根据给定的 File 对象构造一个 FileWriter 对象。</p><p>​    抛出：<code>IOException</code> - 如果该文件存在，但它是一个目录，而不是一个常规文件；或者该文件不存在，但无法创建它；抑或因为其他某些原因而无法打开它</p><p><code>void write(int c)</code>： 写入单个字符。</p><p>​    抛出：<code>IOException</code> - 如果发生 I/O 错误</p><p><code>void write(char[] cbuf)</code>： 写入字符数组。</p><p>​    抛出：<code>IOException</code> - 如果发生 I/O 错误</p><p><code>void write(String str)</code>： 写入字符串。</p><p>​    抛出：<code>IOException</code> - 如果发生 I/O 错误</p><p><code>void flush()</code>：刷新该流的缓冲。</p><p>​    抛出：<code>IOException</code> - 如果发生 I/O 错误</p><p><code>void close()</code>： 关闭此流，但要先刷新它。在关闭该流之后，再调用 write() 或 flush() 将导致抛出 IOException。关闭以前关闭的流无效。</p><p>​    抛出：<code>IOException</code> - 如果发生 I/O 错误</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.bjpowernode.java.io;import java.io.FileWriter;import java.io.IOException;public class FileWriterTest {    public static void main(String[] args) {        FileWriter out = null;        try {            // 创建文件字符输出流对象            //out = new FileWriter("file");            out = new FileWriter("file", true);            // 开始写。            char[] chars = {'我','是','中','国','人'};            out.write(chars);            out.write(chars, 2, 3);            out.write("我是一名java软件工程师！");            // 写出一个换行符。            out.write("\n");            out.write("hello world!");            // 刷新            out.flush();        } catch (IOException e) {            e.printStackTrace();        } finally {            if (out != null) {                try {                    out.close();                } catch (IOException e) {                    e.printStackTrace();                }            }        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="普通文本文件复制"><a href="#普通文本文件复制" class="headerlink" title="普通文本文件复制"></a>普通文本文件复制</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.bjpowernode.java.io;import java.io.FileNotFoundException;import java.io.FileReader;import java.io.FileWriter;import java.io.IOException;/*使用FileReader FileWriter进行拷贝的话，只能拷贝“普通文本”文件。 */public class Copy02 {    public static void main(String[] args) {        FileReader in = null;        FileWriter out = null;        try {            // 读            in = new FileReader("chapter23/src/com/bjpowernode/java/io/Copy02.java");            // 写            out = new FileWriter("Copy02.java");            // 一边读一边写：            char[] chars = new char[1024 * 512]; // 1MB            int readCount = 0;            while((readCount = in.read(chars)) != -1){                out.write(chars, 0, readCount);            }            // 刷新            out.flush();        } catch (FileNotFoundException e) {            e.printStackTrace();        } catch (IOException e) {            e.printStackTrace();        } finally {            if (in != null) {                try {                    in.close();                } catch (IOException e) {                    e.printStackTrace();                }            }            if (out != null) {                try {                    out.close();                } catch (IOException e) {                    e.printStackTrace();                }            }        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="缓冲流"><a href="#缓冲流" class="headerlink" title="缓冲流"></a>缓冲流</h1><h2 id="BufferedReader"><a href="#BufferedReader" class="headerlink" title="BufferedReader"></a>BufferedReader</h2><p> 带有缓冲区的字符输入流。使用这个流的时候不需要自定义char数组，或者说不需要自定义byte数组。自带缓冲。</p><h3 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h3><p><code>BufferedReader(Reader in)</code>： 构造方法，创建一个使用默认大小输入缓冲区的缓冲字符输入流。</p><p>​    参数：<code>in</code> - 一个 Reader</p><p><code>String readLine()</code>： 读取一个文本行。通过下列字符之一即可认为某行已终止：换行 (‘\n’)、回车 (‘\r’) 或回车后直接跟着换行。</p><p>​    返回：包含该行内容的字符串，不包含任何行终止符，如果已到达流末尾，则返回 null</p><p>​    抛出：<code>IOException</code> - 如果发生 I/O 错误</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.bjpowernode.java.io;import java.io.BufferedReader;import java.io.FileReader;public class BufferedReaderTest01 {    public static void main(String[] args) throws Exception{        FileReader reader = new FileReader("Copy02.java");        // 当一个流的构造方法中需要一个流的时候，这个被传进来的流叫做：节点流。        // 外部负责包装的这个流，叫做：包装流，还有一个名字叫做：处理流。        // 像当前这个程序来说：FileReader就是一个节点流。BufferedReader就是包装流/处理流。        BufferedReader br = new BufferedReader(reader);        // 读一行        /*String firstLine = br.readLine();        System.out.println(firstLine);        String secondLine = br.readLine();        System.out.println(secondLine);        String line3 = br.readLine();        System.out.println(line3);*/        // br.readLine()方法读取一个文本行，但不带换行符。        String s = null;        while((s = br.readLine()) != null){            System.out.print(s);        }        // 关闭流        // 对于包装流来说，只需要关闭最外层流就行，里面的节点流会自动关闭。（可以看源代码。）        br.close();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="转换流转换"><a href="#转换流转换" class="headerlink" title="转换流转换"></a>转换流转换</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.bjpowernode.java.io;import java.io.BufferedReader;import java.io.FileInputStream;import java.io.InputStream;import java.io.InputStreamReader;/*    转换流：InputStreamReader */public class BufferedReaderTest02 {    public static void main(String[] args) throws Exception{        /*// 字节流        FileInputStream in = new FileInputStream("Copy02.java");        // 通过转换流转换（InputStreamReader将字节流转换成字符流。）        // in是节点流。reader是包装流。        InputStreamReader reader = new InputStreamReader(in);        // 这个构造方法只能传一个字符流。不能传字节流。        // reader是节点流。br是包装流。        BufferedReader br = new BufferedReader(reader);*/        // 合并        BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream("Copy02.java")));        String line = null;        while((line = br.readLine()) != null){            System.out.println(line);        }        // 关闭最外层        br.close();    }}```<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="BufferedWriter"><a href="#BufferedWriter" class="headerlink" title="BufferedWriter"></a>BufferedWriter</h2><p>BufferedWriter：带有缓冲的字符输出流。<br>OutputStreamWriter：转换流</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.bjpowernode.java.io;import java.io.BufferedWriter;import java.io.FileOutputStream;import java.io.FileWriter;import java.io.OutputStreamWriter;public class BufferedWriterTest {    public static void main(String[] args) throws Exception{        // 带有缓冲区的字符输出流        //BufferedWriter out = new BufferedWriter(new FileWriter("copy"));        BufferedWriter out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream("copy", true)));        // 开始写。        out.write("hello world!");        out.write("\n");        out.write("hello kitty!");        // 刷新        out.flush();        // 关闭最外层        out.close();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h1><h2 id="DataOutputStream"><a href="#DataOutputStream" class="headerlink" title="DataOutputStream"></a>DataOutputStream</h2><p><code>java.io.DataOutputStream</code>：数据字节输字节输出流。</p><p>这个流可以将数据连同数据的类型一并写入文件。</p><p>注意：这个文件不是普通文本文档。（这个文件使用记事本打不开。）</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.bjpowernode.java.io;import java.io.DataOutputStream;import java.io.FileOutputStream;public class DataOutputStreamTest {    public static void main(String[] args) throws Exception{        // 创建数据专属的字节输出流        DataOutputStream dos = new DataOutputStream(new FileOutputStream("data"));        // 写数据        byte b = 100;        short s = 200;        int i = 300;        long l = 400L;        float f = 3.0F;        double d = 3.14;        boolean sex = false;        char c = 'a';        // 写        dos.writeByte(b); // 把数据以及数据的类型一并写入到文件当中。        dos.writeShort(s);        dos.writeInt(i);        dos.writeLong(l);        dos.writeFloat(f);        dos.writeDouble(d);        dos.writeBoolean(sex);        dos.writeChar(c);        // 刷新        dos.flush();        // 关闭最外层        dos.close();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="DataInputStream"><a href="#DataInputStream" class="headerlink" title="DataInputStream"></a>DataInputStream</h2><p>数据字节输入流。</p><p>DataOutputStream写的文件，只能使用DataInputStream去读。并且读的时候你需要提前知道写入的顺序。</p><p>读的顺序需要和写的顺序一致。才可以正常取出数据。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.bjpowernode.java.io;import java.io.DataInputStream;import java.io.FileInputStream;public class DataInputStreamTest01 {    public static void main(String[] args) throws Exception{        DataInputStream dis = new DataInputStream(new FileInputStream("data"));        // 开始读        byte b = dis.readByte();        short s = dis.readShort();        int i = dis.readInt();        long l = dis.readLong();        float f = dis.readFloat();        double d = dis.readDouble();        boolean sex = dis.readBoolean();        char c = dis.readChar();        System.out.println(b);        System.out.println(s);        System.out.println(i + 1000);        System.out.println(l);        System.out.println(f);        System.out.println(d);        System.out.println(sex);        System.out.println(c);        dis.close();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="标准输出流"><a href="#标准输出流" class="headerlink" title="标准输出流"></a>标准输出流</h1><h2 id="PrintStream"><a href="#PrintStream" class="headerlink" title="PrintStream"></a>PrintStream</h2><p><code>java.io.PrintStream</code>：标准的字节输出流。默认输出到控制台。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.bjpowernode.java.io;import java.io.FileOutputStream;import java.io.PrintStream;public class PrintStreamTest {    public static void main(String[] args) throws Exception{        // 联合起来写        System.out.println("hello world!");        // 分开写        PrintStream ps = System.out;        ps.println("hello zhangsan");        ps.println("hello lisi");        ps.println("hello wangwu");        // 可以改变标准输出流的输出方向吗？ 可以        // 标准输出流不再指向控制台，指向“log”文件。        PrintStream printStream = new PrintStream(new FileOutputStream("log"));        // 修改输出方向，将输出方向修改到"log"文件。        System.setOut(printStream);        // 再输出        System.out.println("hello world");        System.out.println("hello kitty");        System.out.println("hello zhangsan");    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><em>注意</em>：标准输出流不需要手动close()关闭。</p></blockquote><h1 id="对象流"><a href="#对象流" class="headerlink" title="对象流"></a>对象流</h1><p><code>ObjectInputStream</code></p><p><code>ObjectOutputStream</code></p><h2 id="序列化与反序列化"><a href="#序列化与反序列化" class="headerlink" title="序列化与反序列化"></a>序列化与反序列化</h2><p>序列化：将类保存到硬盘</p><p>反序列化： 将序列化后的类还原成java类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.bjpowernode.java.io;import com.bjpowernode.java.bean.Student;import java.io.FileOutputStream;import java.io.ObjectOutputStream;public class ObjectOutputStreamTest01 {    public static void main(String[] args) throws Exception{        // 创建java对象        Student s = new Student(1111, "zhangsan");        // 序列化        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("students"));        // 序列化对象        oos.writeObject(s);        // 刷新        oos.flush();        // 关闭        oos.close();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li><p>当Student没有实现接口Serializable时，异常：java.io.NotSerializableException:</p><pre><code>Student对象不支持序列化！！！！</code></pre></li><li><p>参与序列化和反序列化的对象，必须实现Serializable接口。</p></li><li><p>注意：通过源代码发现，Serializable接口只是一个标志接口：</p><pre><code>public interface Serializable {}这个接口当中什么代码都没有。那么它起到一个什么作用呢？    起到标识的作用，标志的作用，java虚拟机看到这个类实现了这个接口，可能会对这个类进行特殊待遇。    Serializable这个标志接口是给java虚拟机参考的，java虚拟机看到这个接口之后，会为该类自动生成一个序列化版本号。</code></pre></li></ol><p>Student类：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.bjpowernode.java.bean;import java.io.Serializable;public class Student implements Serializable {    private int no;    private String name;        public Student() {    }    public Student(int no, String name) {        this.no = no;        //this.name = name;    }    public int getNo() {        return no;    }    public void setNo(int no) {        this.no = no;    }    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }    @Override    public String toString() {        return "Student{" +                "no=" + no +                ", name='" + name + '\'' +                '}';    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="一次性序列化多个对象"><a href="#一次性序列化多个对象" class="headerlink" title="一次性序列化多个对象"></a>一次性序列化多个对象</h2><p>一次序列化多个对象，可以将对象放到集合当中，序列化集合。</p><blockquote><p>提示： 参与序列化的ArrayList集合以及集合中的元素User都需要实现 java.io.Serializable接口。</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.bjpowernode.java.io;import com.bjpowernode.java.bean.User;import java.io.FileOutputStream;import java.io.ObjectOutputStream;import java.util.ArrayList;import java.util.List;public class ObjectOutputStreamTest02 {    public static void main(String[] args) throws Exception{        List&lt;User&gt; userList = new ArrayList&lt;&gt;();        userList.add(new User(1,"zhangsan"));        userList.add(new User(2, "lisi"));        userList.add(new User(3, "wangwu"));        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("users"));        // 序列化一个集合，这个集合对象中放了很多其他对象。        oos.writeObject(userList);        oos.flush();        oos.close();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>反序列化集合: </p><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.bjpowernode.java.io;import com.bjpowernode.java.bean.User;import java.io.FileInputStream;import java.io.ObjectInputStream;import java.util.List;public class ObjectInputStreamTest02 {    public static void main(String[] args) throws Exception{        ObjectInputStream ois = new ObjectInputStream(new FileInputStream("users"));        //Object obj = ois.readObject();        //System.out.println(obj instanceof List);        List&lt;User&gt; userList = (List&lt;User&gt;)ois.readObject();        for(User user : userList){            System.out.println(user);        }        ois.close();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="transient关键字"><a href="#transient关键字" class="headerlink" title="transient关键字"></a>transient关键字</h2><p>在实际开发过程中，我们常常会遇到这样的问题，这个类的有些属性需要序列化，而其他属性不需要被序列化，打个比方，如果一个用户有一些敏感信息（如密码，银行卡号等），为了安全起见，不希望在网络操作（主要涉及到序列化操作，本地序列化缓存也适用）中被传输，这些信息对应的变量就可以加上transient关键字。换句话说，这个字段的生命周期仅存于调用者的内存中而不会写到磁盘里持久化。</p><p>   总之，java 的transient关键字为我们提供了便利，你只需要实现Serilizable接口，将不需要序列化的属性前添加关键字transient，序列化对象的时候，这个属性就不会序列化到指定的目的地中。</p><p>1）一旦变量被transient修饰，变量将不再是对象持久化的一部分，该变量内容在序列化后无法获得访问。</p><p>2）transient关键字只能修饰变量，而不能修饰方法和类。注意，本地变量是不能被transient关键字修饰的。变量如果是用户自定义类变量，则该类需要实现Serializable接口。</p><p>3）被transient关键字修饰的变量不再能被序列化，一个静态变量不管是否被transient修饰，均不能被序列化。</p><h2 id="序列化版号"><a href="#序列化版号" class="headerlink" title="序列化版号"></a>序列化版号</h2><p><strong><em>序列化版本号有什么用呢？</em></strong></p><p>​    当类的原代码发生变动，通过原来的序列化文件进行反序列化，则会报错：</p><p>​    <code>java.io.InvalidClassException:</code><br>​        <code>com.bjpowernode.java.bean.Student;</code><br>​        <code>local class incompatible:</code><br>​            <code>stream classdesc serialVersionUID = -684255398724514298（改动后）,</code><br>​            <code>local class serialVersionUID = -3463447116624555755（改动前）</code></p><p>java语言中是采用什么机制来区分类的？<br>    第一：首先通过类名进行比对，如果类名不一样，肯定不是同一个类。<br>    第二：如果类名一样，再怎么进行类的区别？靠序列化版本号进行区分。</p><p>小鹏编写了一个类：<code>com.bjpowernode.java.bean.Student implements Serializable</code><br>胡浪编写了一个类：<code>com.bjpowernode.java.bean.Student implements Serializable</code><br>不同的人编写了同一个类，但“这两个类确实不是同一个类”。这个时候序列化版本就起上作用了。<br>对于java虚拟机来说，java虚拟机是可以区分开这两个类的，因为这两个类都实现了Serializable接口，<br>都有默认的序列化版本号，他们的序列化版本号不一样。所以区分开了。（这是自动生成序列化版本号的好处）</p><p>  <strong><em>这种自动生成序列化版本号有什么缺陷？</em></strong><br>        这种自动生成的序列化版本号缺点是：一旦代码确定之后，不能进行后续的修改，<br>        因为只要修改，必然会重新编译，此时会生成全新的序列化版本号，这个时候java<br>        虚拟机会认为这是一个全新的类。（这样就不好了！）</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.bjpowernode.java.bean;import java.io.Serializable;public class Student implements Serializable {       private static final long serialVersionUID = 1L; // java虚拟机识别一个类的时候先通过类名，如果类名一致，再通过序列化版本号。    private int no;    //private String name;    // 过了很久，Student这个类源代码改动了。    // 源代码改动之后，需要重新编译，编译之后生成了全新的字节码文件。    // 并且class文件再次运行的时候，java虚拟机生成的序列化版本号也会发生相应的改变。    private int age;    private String email;    private String address;    public Student() {    }    public Student(int no, String name) {        this.no = no;        //this.name = name;    }    public int getNo() {        return no;    }    public void setNo(int no) {        this.no = no;    }    /*public String getName() {        return name;    }*/    /*public void setName(String name) {        this.name = name;    }*/    /*@Override    public String toString() {        return "Student{" +                "no=" + no +                ", name='" + name + '\'' +                '}';    }*/    @Override    public String toString() {        return "Student{" +                "no=" + no +                ", age=" + age +                ", email='" + email + '\'' +                ", address='" + address + '\'' +                '}';    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Java虚拟机看到Serializable接口之后，会自动生成一个序列化版本号。</p><p>这里没有手动写出来，java虚拟机会默认提供这个序列化版本号。</p><p>建议将序列化版本号手动的写出来。不建议自动生成</p><p><strong>最终结论：</strong><br>    凡是一个类实现了Serializable接口，建议给该类提供一个固定不变的序列化版本号。这样，以后这个类即使代码修改了，但是版本号不变，java虚拟机会认为是同一个类。</p><blockquote><p>  重点 ：<br>    参与序列化的类型必须实现java.io.Serializable接口。<br>    并且建议将序列化版本号手动的写出来。<br>     <code>private static final long serialVersionUID = 1L;</code></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JavaSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> IO流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java 集合</title>
      <link href="/2021/11/03/%E9%9B%86%E5%90%88/"/>
      <url>/2021/11/03/%E9%9B%86%E5%90%88/</url>
      
        <content type="html"><![CDATA[<h1 id="Java集合结构"><a href="#Java集合结构" class="headerlink" title="Java集合结构"></a>Java集合结构</h1><h2 id="集合概述"><a href="#集合概述" class="headerlink" title="集合概述"></a>集合概述</h2><ol><li><p>什么是集合？有什么用？</p><p>数组其实就是一种集合。集合实际上就是一种容器。可以用来容纳其他类型的数据。</p><p>集合为什么说在开发中使用较多？</p><p>​    集合是一个容器，是一个载体,可以一次容纳多个对象。在实际开发中，假设连接数据库，数据库当中有10条记录，那么假设把这10条记录查询出来，在java程序中会将10条数据封装成10个java对象，然后将10个java对象放到某一个集合当中，将集合传到前端，然后遍历集合，将一个数据一个数据展现出来。</p></li><li><p>集合不能直接存储基本数据类型，另外集合也不能直接存储java对象，集合当中存储的都是java对象的内存地址。(或者说集合中存储的是引用。)</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">list.add (100) ; //自动装箱integer<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><blockquote><p>注意：</p><p>​    集合在java中本身是一个容器，是一个对象。</p><p>​    集合中任何时候存储的都是“引用”。</p></blockquote><p>   <img src="https://cdn.jsdelivr.net/gh/DZ-O/CDN/img/image-20211103181202843.png" alt="集合"></p><ol><li><p>在java中每一个不同的集合，底层会对应不同的数据结构。往不同的集合中存储元素，等于将数据放到了不同的数据结构当中。</p></li><li><p>所有的集合类和集合接口都在<code>java.util</code>包下.</p></li></ol><h2 id="集合的继承结构"><a href="#集合的继承结构" class="headerlink" title="集合的继承结构"></a>集合的继承结构</h2><p>java中集合分为两大类：</p><ol><li><p>单个方式储存元素</p><p>单个方式存储元素，这一类集合中超级父接口：<code>java.util.Collection</code>;</p><p><img src="https://cdn.jsdelivr.net/gh/DZ-O/CDN/img/image-20211103204030702.png" alt="Collection继承结构"></p></li></ol><ol><li><p>以键值对方式存储元素：</p><p>以键值对存储元素，这一类集合中的超级父接口：<code>java.util.Map</code>;</p><p><img src="https://cdn.jsdelivr.net/gh/DZ-O/CDN/img/image-20211103204056234.png" alt="Map继承结构"></p></li></ol><p>总结：</p><ul><li>ArrayList: 底层是数组。</li><li>LinkedList: 底层是双向链表。</li><li>Vector: 底层是数组，线程安全的，效率较低，使用较少。</li><li>HashSet: 底层是HashMap，放到HashSet.集合中的元素等同于放到HashMap集合key部分了。</li><li>TreeSet: 底层是 TreeMap，放到TreeSet.集合中的元素等同于放到TreeMap.集合key部分了。</li><li>HashMap: 底层是哈希表。</li><li>Hashtable: 底层也是哈希表，只不过线程安全的，效率较低，使用较少。</li><li>Properties: 是线程安全的，并且 key 和value只能存储字符串String。</li><li>TreeMap: 底层是二叉树。TreeMap集合的 key可以自动按照大小顺序排序。</li></ul><h1 id="Collection接口"><a href="#Collection接口" class="headerlink" title="Collection接口"></a>Collection接口</h1><h2 id="常用方法："><a href="#常用方法：" class="headerlink" title="常用方法："></a>常用方法：</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java">/*关于java.util.Collection接口中常用的方法。    1、Collection中能存放什么元素？        没有使用“泛型”之前，Collection中可以存储Object的所有子类型。        使用了“泛型”之后，Collection中只能存储某个具体的类型。        集合后期我们会学习“泛型”语法。目前先不用管。Collection中什么都能存，        只要是Object的子类型就行。（集合中不能直接存储基本数据类型，也不能存        java对象，只是存储java对象的内存地址。）    2、Collection中的常用方法        boolean add(Object e) 向集合中添加元素        int size()  获取集合中元素的个数        void clear() 清空集合        boolean contains(Object o) 判断当前集合中是否包含元素o，包含返回true，不包含返回false        boolean remove(Object o) 删除集合中的某个元素。        boolean isEmpty()  判断该集合中元素的个数是否为0        Object[] toArray()  调用这个方法可以把集合转换成数组。【作为了解，使用不多。】 */public class CollectionTest01 {    public static void main(String[] args) {        // 创建一个集合对象        //Collection c = new Collection(); // 接口是抽象的，无法实例化。        // 多态        Collection c = new ArrayList();        // 测试Collection接口中的常用方法        c.add(1200); // 自动装箱(java5的新特性。),实际上是放进去了一个对象的内存地址。Integer x = new Integer(1200);        c.add(3.14); // 自动装箱        c.add(new Object());        c.add(new Student());        c.add(true); // 自动装箱        // 获取集合中元素的个数        System.out.println("集合中元素个数是：" + c.size()); // 5        // 清空集合        c.clear();        System.out.println("集合中元素个数是：" + c.size()); // 0        // 再向集合中添加元素        c.add("hello"); // "hello"对象的内存地址放到了集合当中。        c.add("world");        c.add("浩克");        c.add("绿巨人");        c.add(1);        // 判断集合中是否包含"绿巨人"        boolean flag = c.contains("绿巨人");        System.out.println(flag); // true        boolean flag2 = c.contains("绿巨人2");        System.out.println(flag2); // false        System.out.println(c.contains(1)); // true        System.out.println("集合中元素个数是：" + c.size()); // 5        // 删除集合中某个元素        c.remove(1);        System.out.println("集合中元素个数是：" + c.size()); // 4        // 判断集合是否为空（集合中是否存在元素）        System.out.println(c.isEmpty()); // false        // 清空        c.clear();        System.out.println(c.isEmpty()); // true（true表示集合中没有元素了！）        c.add("abc");        c.add("def");        c.add(100);        c.add("helloworld!");        c.add(new Student());        // 转换成数组（了解，使用不多。）        Object[] objs = c.toArray();        for(int i = 0; i &lt; objs.length; i++){            // 遍历数组            Object o = objs[i];            System.out.println(o);        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Iterator迭代器"><a href="#Iterator迭代器" class="headerlink" title="Iterator迭代器"></a>Iterator迭代器</h2><p><strong>迭代</strong>∶即Collection集合元素的通用获取方式。在取元素之前先要判断集合中有没有元素,如果有，就把这个元素取出来，继续在判断，如果还有就再取出出来。一直把集合中的所有元素全部取出。这种取出方式专业术语称为迭代。</p><p>在程序开发中，经常需要遍历集合中的所有元素。针对这种需求，JDK专门提供了一个接口<code>java.util.Iterator</code>。Iterator 接口也是Java集合中的一员，但它与Collection 、Map接口有所不同，Collection,接口与Map接口主要用于存储元素，而Iterator主要用于迭代访问(即遍历) Collection 中的元素，因此Iterator对象也被称为迭代器。</p><p>想要遍历Collection集合，那么就要获取该集合迭代器完成迭代操作，下面介绍一下获取迭代器的方法︰</p><p><code>public Iterator iterator():获取集合对应的迭代器，用来遍历集合中的元素的。</code></p><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><p><code>boolean hasNext(）</code>判断集合中还有没有下一个元素,有就返回true,没有就返回false。</p><p><code>E next(）</code>返回迭代的下一个元素。取出集合中的下一个元素</p><p>Iterator迭代器,是一个接口,我们无法直接使用,需要使用Iterator接口的实现类对象,获取实现类的方式比较特殊collection接口中有一个方法,叫<code>iterator()</code> ,这个方法返回的就是迭代器的实现类对象</p><p><code>Iterator&lt;E&gt; iterator(）</code>返回在此collection 的元素上进行迭代的迭代器。迭代器的使用步骤(重点)∶</p><ol><li>使用集合中的方法iterator()获取迭代器的实现类对象,使用Iterator接口接收(多态)</li><li>使用Iterator接口中的方法<code>boolean hasNext</code>判断还有没有下一个元素</li><li>使用Iterator接口中的方法<code>E next</code>取出集合中的下一个元素</li><li><code>void remove()</code>从迭代器指向的collection中移除迭代器返回的最后一个元素(可选操作)。</li></ol><blockquote><p>注意：Iterator<e>接口也是有泛型的,迭代器的泛型跟着集合走,集合是什么泛型,迭代器就是什么泛型</e></p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.bjpowernode.javase.collection;import java.util.ArrayList;import java.util.Collection;import java.util.Iterator;/** * 关于集合遍历/迭代专题。（重点：五颗星*****） */public class CollectionTest02 {    public static void main(String[] args) {        // 注意：以下讲解的遍历方式/迭代方式，是所有Collection通用的一种方式。        // 在Map集合中不能用。在所有的Collection以及子类中使用。        // 创建集合对象        Collection c = new ArrayList(); // 后面的集合无所谓，主要是看前面的Collection接口，怎么遍历/迭代。        // 添加元素        c.add("abc");        c.add("def");        c.add(100);        c.add(new Object());        // 对集合Collection进行遍历/迭代        // 第一步：获取集合对象的迭代器对象Iterator        Iterator it = c.iterator();        // 第二步：通过以上获取的迭代器对象开始迭代/遍历集合。        /*            以下两个方法是迭代器对象Iterator中的方法：                boolean hasNext()如果仍有元素可以迭代，则返回 true。                Object next() 返回迭代的下一个元素。         */        while(it.hasNext()){            Object obj = it.next();            System.out.println(obj);        }        // 一直取，不判断，会出现异常：java.util.NoSuchElementException        /*while(true){            Object obj = it.next();            System.out.println(obj);        }*/        /* while(it.hasNext()){            // 存进去是什么类型，取出来还是什么类型。            Object obj = it.next();            if(obj instanceof Integer){                System.out.println("Integer类型");            }            // 只不过在输出的时候会转换成字符串。因为这里println会调用toString()方法。            System.out.println(obj);        }*/    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/DZ-O/CDN/img/image-20211104205114174.png" alt="迭代集合原理"></p><blockquote><p>注意：</p><p>​    重点：当集合的结构发生改变时，迭代器必须重新获取，如果还是用以前老的迭代器，会出现异常：<code>java.util.ConcurrentModificationException</code></p><p>​    重点：在迭代集合元素的过程中，不能调用集合对象的remove方法，删除元素：</p><p>​        <code>c.remove(o);</code> 迭代过程中不能这样。会出现：<code>java.util.ConcurrentModificationException</code></p><p>​     重点：在迭代元素的过程当中，一定要使用迭代器Iterator的remove方法，删除元素，不要使用集合自带的remove方法删除元素。</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class CollectionTest06 {    public static void main(String[] args) {        // 创建集合        Collection c = new ArrayList();        // 注意：此时获取的迭代器，指向的是那是集合中没有元素状态下的迭代器。        // 一定要注意：集合结构只要发生改变，迭代器必须重新获取。        // 当集合结构发生了改变，迭代器没有重新获取时，调用next()方法时：java.util.ConcurrentModificationException        Iterator it = c.iterator();        // 添加元素        c.add(1); // Integer类型        c.add(2);        c.add(3);        // 获取迭代器        //Iterator it = c.iterator();        /*while(it.hasNext()){            // 编写代码时next()方法返回值类型必须是Object。            // Integer i = it.next();            Object obj = it.next();            System.out.println(obj);        }*/        Collection c2 = new ArrayList();        c2.add("abc");        c2.add("def");        c2.add("xyz");        Iterator it2 = c2.iterator();        while(it2.hasNext()){            Object o = it2.next();            // 删除元素            // 删除元素之后，集合的结构发生了变化，应该重新去获取迭代器            // 但是，循环下一次的时候并没有重新获取迭代器，所以会出现异常：java.util.ConcurrentModificationException            // 出异常根本原因是：集合中元素删除了，但是没有更新迭代器（迭代器不知道集合变化了）            //c2.remove(o); // 直接通过集合去删除元素，没有通知迭代器。（导致迭代器的快照和原集合状态不同。）            // 使用迭代器来删除可以吗？            // 迭代器去删除时，会自动更新迭代器，并且更新集合（删除集合中的元素）。            it2.remove(); // 删除的一定是迭代器指向的当前元素。            System.out.println(o);        }        System.out.println(c2.size()); //0    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="List接口"><a href="#List接口" class="headerlink" title="List接口"></a>List接口</h1><p>List集合存储元素特点：有序可重复</p><p>​    有序：List集合中的元素有下标。</p><p>​    从0开始，以1递增。</p><p>​    可重复：存储一个1，还可以再存储1.</p><p>List既然是Collection接口的子接口，那么肯定List接口有自己“特色”的方法：</p><p>​    以下只列出List接口特有的常用的方法：</p><p>​      <code>void add(int index, E element)</code>: 在列表的指定位置插入指定元素（第一个参数是下标）</p><p>​      <code>E set(int index, E element)</code>：用指定元素替换列表中指定位置的元素。</p><p>​      <code>E get(int index)</code>: 返回列表中指定位置的元素</p><p>​      <code>int indexOf(Object o)</code>：返回此列表中第一次出现的指定元素的索引;如果此列表不包含该元素，则返回-1。</p><p>​      <code>int lastIndexOf(Object o)</code>：返回此列表中最后出现的指定元素的索引;如果列表不包含此元素，则返回-1。</p><p>​      <code>E remove(int index)</code>：移除列表中指定位置的元素。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class ListTest01 {    public static void main(String[] args) {        // 创建List类型的集合。        //List myList = new LinkedList();        //List myList = new Vector();        List myList = new ArrayList();        // 添加元素        myList.add("A"); // 默认都是向集合末尾添加元素。        myList.add("B");        myList.add("C");        myList.add("C");        myList.add("D");        //在列表的指定位置插入指定元素（第一个参数是下标）        // 这个方法使用不多，因为对于ArrayList集合来说效率比较低。        myList.add(1, "KING");        // 迭代        Iterator it = myList.iterator();        while(it.hasNext()){            Object elt = it.next();            System.out.println(elt);        }        // 根据下标获取元素        Object firstObj = myList.get(0);        System.out.println(firstObj);        // 因为有下标，所以List集合有自己比较特殊的遍历方式        // 通过下标遍历。【List集合特有的方式，Set没有。】        for(int i = 0; i &lt; myList.size(); i++){            Object obj = myList.get(i);            System.out.println(obj);        }        // 获取指定对象第一次出现处的索引。        System.out.println(myList.indexOf("C")); // 3        // 获取指定对象最后一次出现处的索引。        System.out.println(myList.lastIndexOf("C")); // 4        // 删除指定下标位置的元素        // 删除下标为0的元素        myList.remove(0);        System.out.println(myList.size()); // 5        System.out.println("====================================");        // 修改指定位置的元素        myList.set(2, "Soft");        // 遍历集合        for(int i = 0; i &lt; myList.size(); i++){            Object obj = myList.get(i);            System.out.println(obj);        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="ArrayList集合"><a href="#ArrayList集合" class="headerlink" title="ArrayList集合"></a>ArrayList集合</h1><blockquote><ol><li><p>默认初始化容量10（底层先创建了一个长度为0的数组，当添加第一个元素的时候，初始化容量10。）</p></li><li><p>集合底层是一个Object[ ]数组。</p></li><li><p>构造方法：</p><p>​    <code>new ArrayList();</code>  构造一个初始容量为10的空列表。</p><p>​    <code>new ArrayList(Collection&lt;?extends E&gt; c)</code> 构造一个包含指定collection的元素的列表，这些元素是按照该collection的迭代器返回它们的顺序排列的。</p><p>​    <code>new ArrayList(int initialCapacity);</code>  构造一个具有指定初始容量的空列表。</p></li><li><p>ArrayList集合的扩容：</p><p>​    增长到原容量的1.5倍。</p><p>​    <strong><em>ArrayList集合底层是数组，怎么优化？</em></strong></p><p>​          尽可能少的扩容。因为数组扩容效率比较低，建议在使用ArrayList集合的时候预估计元素的个数，给定一个初始化容量。</p></li><li><p>数组优点：</p><p>​    检索效率比较高。（每个元素占用空间大小相同，内存地址是连续的，知道首元素内存地址，然后知道下标，通过数学表达式计算出元素的内存地址，所以检索效率最高。）</p></li><li><p>数组缺点：</p><p>​    随机增删元素效率比较低。另外数组无法存储大数据量。（很难找到一块非常巨大的连续的内存空间。）</p></li><li><p>向数组末尾添加元素，效率很高，不受影响。</p></li><li><p>面试官经常问的一个问题</p><p>​    <strong><em>这么多的集合中，你用哪个集合最多？</em></strong></p><p>​      答：ArrayList集合。因为往数组末尾添加元素，效率不受影响。另外，我们检索/查找某个元素的操作比较多。</p></li><li><p>ArrayList集合是非线程安全的。（不是线程安全的集合。）</p></li></ol></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class ArrayListTest02 {    public static void main(String[] args) {        // 默认初始化容量10        List myList1 = new ArrayList();        // 指定初始化容量100        List myList2 = new ArrayList(100);        // 创建一个HashSet集合        Collection c = new HashSet();        // 添加元素到Set集合        c.add(100);        c.add(200);        c.add(900);        c.add(50);        // 通过这个构造方法就可以将HashSet集合转换成List集合。        List myList3 = new ArrayList(c);        for(int i = 0; i &lt; myList3.size(); i++){            System.out.println(myList3.get(i));        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="LinkedList集合"><a href="#LinkedList集合" class="headerlink" title="LinkedList集合"></a><strong>LinkedList集合</strong></h1><p>LinkedList集合的特点∶</p><ol><li><p>底层是一个链表结构;查询慢,增删快</p></li><li><p>里边包含了大量操作首尾元素的方法</p><p>注意:使用Linkedlist集合特有的方法,不能使用多态</p><blockquote><p>链表的优点：</p><p>  由于链表上的元素在空间存储上内存地址不连续。所以随机增删元素的时候不会有大量元素位移，因此随机增删效率较高。</p><p>  在以后的开发中，如果遇到随机增删集合中元素的业务比较多时，建议 使用LinkedList。</p><p>链表的缺点：</p><p>  不能通过数学表达式计算被查找元素的内存地址，每一次查找都是从头节点开始遍历，直到找到为止。所以LinkedList集合检索/查找的效率较低。</p><p>  ArrayList：把检索发挥到极致。（末尾添加元素效率还是很高的。）</p><p>  LinkedList：把随机增删发挥到极致。</p><p>  加元素都是往末尾添加，所以ArrayList用的比LinkedList多。 </p></blockquote></li></ol><p>LinkedList特有方法：</p><ul><li><code>public void addFirst(E e)</code>: 将指定元素插入此列表的开头。</li><li><code>public void addLast(E e)</code>: 将指定元素添加到此列表的结尾。</li><li><code>public void push(E e)</code>: 将元素推入此列表所表示的堆栈。</li><li><code>public E getFirst()</code>: 返回此列表的第一个元素。</li><li><code>public E getLast()</code>: 返回此列表的最后一个元素。</li><li><code>public E removeFirst()</code>: 移除并返回此列表的第一个元素。</li><li><code>public E removeLast()</code>: 移除并返回此列表的最后一个元素。</li><li><code>public E pop()</code>: 从此列表所表示的堆栈处弹出一个元素。</li><li><code>public boolean isEmpty()</code>: 如果列表不包含元素，则返回true。</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class LinkedListDemo {    public static void main(String[] args) {        show03();    }    private static void show03() {        LinkedList&lt;String&gt; linkedList = new LinkedList&lt;&gt;();        linkedList.add("a");        linkedList.add("b");        linkedList.add("c");//        String s = linkedList.removeFirst();        String s = linkedList.pop();        System.out.println(s);        String s1 = linkedList.removeLast();        System.out.println(s1);        System.out.println(linkedList);    }    private static void show02() {        LinkedList&lt;String&gt; linkedList = new LinkedList&lt;&gt;();        linkedList.add("a");        linkedList.add("b");        linkedList.add("c");        String first = linkedList.getFirst();        System.out.println(first);        String last = linkedList.getLast();        System.out.println(last);        String tow = linkedList.get(1);        System.out.println(tow);    }    private static void show01() {        LinkedList&lt;String&gt; linkedList = new LinkedList&lt;&gt;();        linkedList.add("a");        linkedList.add("b");        linkedList.add("c");        linkedList.addLast("com");   // 等效于 add（）        System.out.println(linkedList);//        linkedList.addFirst("www");        linkedList.push("www");        System.out.println(linkedList);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class LinkedListTest01 {    public static void main(String[] args) {        // LinkedList集合底层也是有下标的。        // 注意：ArrayList之所以检索效率比较高，不是单纯因为下标的原因。是因为底层数组发挥的作用。        // LinkedList集合照样有下标，但是检索/查找某个元素的时候效率比较低，因为只能从头节点开始一个一个遍历。        List list = new LinkedList();        list.add("a");        list.add("b");        list.add("c");        for(int i = 0; i &lt;list.size(); i++){            Object obj = list.get(i);            System.out.println(obj);        }        // LinkedList集合有初始化容量吗？没有。        // 最初这个链表中没有任何元素。first和last引用都是null。        // 不管是LinkedList还是ArrayList，以后写代码时不需要关心具体是哪个集合。        // 因为我们要面向接口编程，调用的方法都是接口中的方法。        //List list2 = new ArrayList(); // 这样写表示底层你用了数组。        List list2 = new LinkedList(); // 这样写表示底层你用了双向链表。        // 以下这些方法你面向的都是接口编程。        list2.add("123");        list2.add("456");        list2.add("789");        for(int i = 0; i &lt; list2.size(); i++){            System.out.println(list2.get(i));        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="Vector集合"><a href="#Vector集合" class="headerlink" title="Vector集合"></a>Vector集合</h1><ol><li><p>底层也是一个数组。</p></li><li><p>初始化容量：10</p></li><li><p>怎么扩容的？</p><p>​    扩容之后是原容量的2倍。10—&gt; 20 —&gt; 40 —&gt; 80</p></li><li><p>ArrayList集合扩容特点：ArrayList集合扩容是原容量1.5倍。</p></li><li><p>Vector中所有的方法都是线程同步的，都带有synchronized关键字，是线程安全的。效率比较低，使用较少了。</p></li><li><p><strong><em>怎么将一个线程不安全的ArrayList集合转换成线程安全的呢？</em></strong></p><p>使用集合工具类：<code>java.util.Collections</code>;</p><p>​    java.util.Collection 是集合接口。</p><p>​    java.util.Collections 是集合工具类。</p></li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class VectorTest {    public static void main(String[] args) {        // 创建一个Vector集合        List vector = new Vector();        //Vector vector = new Vector();        // 添加元素        // 默认容量10个。        vector.add(1);        vector.add(2);        vector.add(3);        vector.add(4);        vector.add(5);        vector.add(6);        vector.add(7);        vector.add(8);        vector.add(9);        vector.add(10);        // 满了之后扩容（扩容之后的容量是20.）        vector.add(11);        Iterator it = vector.iterator();        while(it.hasNext()){            Object obj = it.next();            System.out.println(obj);        }        // 这个可能以后要使用！！！！        List myList = new ArrayList(); // 非线程安全的。        // 变成线程安全的        Collections.synchronizedList(myList);         // myList集合就是线程安全的了。        myList.add("111");        myList.add("222");        myList.add("333");    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="HashSet集合"><a href="#HashSet集合" class="headerlink" title="HashSet集合"></a>HashSet集合</h1><p>HashSet集合在new的时候,底层实际上new了一个HashMap集合。向Hashset集合中存储元紊,实际上是存储到HashMap集合中了。</p><p>HashMap集合是一个哈希表数据结构Hashset集合初始化容量16</p><p>初始化容量建议是2的倍数。</p><p>扩容: 扩容之后是原容量2倍。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.bjpowernode.javase.collection;import java.util.HashSet;import java.util.Set;/*HashSet集合：    无序不可重复。 */public class HashSetTest01 {    public static void main(String[] args) {        // 演示一下HashSet集合特点        Set&lt;String&gt; strs = new HashSet&lt;&gt;();        // 添加元素        strs.add("hello3");        strs.add("hello4");        strs.add("hello1");        strs.add("hello2");        strs.add("hello3");        strs.add("hello3");        strs.add("hello3");        strs.add("hello3");        // 遍历        /*        hello1        hello4        hello2        hello3        1、存储时顺序和取出的顺序不同。        2、不可重复。        3、放到HashSet集合中的元素实际上是放到HashMap集合的key部分了。         */        for(String s : strs){            System.out.println(s);        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h1 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h1><ol><li>Map集合和Collection集合没有关系。</li><li>Map集合以key和value的这种键值对的方式存储元素。</li><li>key和value都是存储java对象的内存地址。</li><li>所有Map集合的key特点:无序不可重复的。Map集合的key和Set集合存储元素特点相同。</li></ol><h2 id="Map常用方法"><a href="#Map常用方法" class="headerlink" title="Map常用方法"></a>Map常用方法</h2><p>​    <code>V put(K key, V value)</code> 向Map集合中添加键值对</p><p>​    <code>V get(Object key)</code> 通过key获取value</p><p>​    <code>void clear()</code>   清空Map集合</p><p>​    <code>boolean containsKey(Object key)</code> 判断Map中是否包含某个key</p><p>​    <code>boolean containsValue(Object value)</code> 判断Map中是否包含某个value</p><p>​    <code>boolean isEmpty()</code>  判断Map集合中元素个数是否为0</p><p>​    <code>V remove(Object key)</code> 通过key删除键值对</p><p>​    <code>int size()</code> 获取Map集合中键值对的个数。</p><p>​    <code>Collection&lt;V&gt; values()</code> 获取Map集合中所有的value，返回一个Collection</p><p>​    <code>Set&lt;K&gt; keySet()</code> 获取Map集合所有的key（所有的键是一个set集合）</p><p>​     <code>Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</code>  将Map集合转换成Set集合,假设现在有一个Map集合，如下所示：</p><p>​    </p><div class="table-container"><table><thead><tr><th style="text-align:center">key</th><th style="text-align:center">value</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">zhangsan</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">lisi</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">wangwu</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">zhaoliu</td></tr></tbody></table></div><p><code>Set set = map1.entrySet();</code></p><div class="table-container"><table><thead><tr><th style="text-align:center">set集合对象</th></tr></thead><tbody><tr><td style="text-align:center">1=zhangsan</td></tr><tr><td style="text-align:center">2=lisi</td></tr><tr><td style="text-align:center">3=wangwu</td></tr><tr><td style="text-align:center">4=zhaoliu</td></tr></tbody></table></div><blockquote><p>【注意：Map集合通过entrySet()方法转换成的这个Set集合，Set集合中元素的类型是 Map.Entry<k,v>】</k,v></p><p>【Map.Entry和String一样，都是一种类型的名字，只不过：Map.Entry是静态内部类，是Map中的静态内部类】</p><p> 4=zhaoliu —-&gt; 这个东西是个什么？ Map.Entry</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class MapTest01 {    public static void main(String[] args) {        // 创建Map集合对象        Map&lt;Integer, String&gt; map = new HashMap&lt;&gt;();        // 向Map集合中添加键值对        map.put(1, "zhangsan"); // 1在这里进行了自动装箱。        map.put(2, "lisi");        map.put(3, "wangwu");        map.put(4, "zhaoliu");        // 通过key获取value        String value = map.get(2);        System.out.println(value);        // 获取键值对的数量        System.out.println("键值对的数量：" + map.size());        // 通过key删除key-value        map.remove(2);        System.out.println("键值对的数量：" + map.size());        // 判断是否包含某个key        // contains方法底层调用的都是equals进行比对的，所以自定义的类型需要重写equals方法。        System.out.println(map.containsKey(new Integer(4))); // true        // 判断是否包含某个value        System.out.println(map.containsValue(new String("wangwu"))); // true        // 获取所有的value        Collection&lt;String&gt; values = map.values();        // foreach        for(String s : values){            System.out.println(s);        }        // 清空map集合        map.clear();        System.out.println("键值对的数量：" + map.size());        // 判断是否为空        System.out.println(map.isEmpty()); // true    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Map集合遍历"><a href="#Map集合遍历" class="headerlink" title="Map集合遍历"></a>Map集合遍历</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class MapTest02 {    public static void main(String[] args) {        // 第一种方式：获取所有的key，通过遍历key，来遍历value        Map&lt;Integer, String&gt; map = new HashMap&lt;&gt;();        map.put(1, "zhangsan");        map.put(2, "lisi");        map.put(3, "wangwu");        map.put(4, "zhaoliu");        // 遍历Map集合        // 获取所有的key，所有的key是一个Set集合        Set&lt;Integer&gt; keys = map.keySet();        // 遍历key，通过key获取value        // 迭代器可以        /*Iterator&lt;Integer&gt; it = keys.iterator();        while(it.hasNext()){            // 取出其中一个key            Integer key = it.next();            // 通过key获取value            String value = map.get(key);            System.out.println(key + "=" + value);        }*/        // foreach也可以        for(Integer key : keys){            System.out.println(key + "=" + map.get(key));        }        // 第二种方式：Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()        // 以上这个方法是把Map集合直接全部转换成Set集合。        // Set集合中元素的类型是：Map.Entry        Set&lt;Map.Entry&lt;Integer,String&gt;&gt; set = map.entrySet();        // 遍历Set集合，每一次取出一个Node        // 迭代器        /*Iterator&lt;Map.Entry&lt;Integer,String&gt;&gt; it2 = set.iterator();        while(it2.hasNext()){            Map.Entry&lt;Integer,String&gt; node = it2.next();            Integer key = node.getKey();            String value = node.getValue();            System.out.println(key + "=" + value);        }*/        // foreach        // 这种方式效率比较高，因为获取key和value都是直接从node对象中获取的属性值。        // 这种方式比较适合于大数据量。        for(Map.Entry&lt;Integer,String&gt; node : set){            System.out.println(node.getKey() + "---&gt;" + node.getValue());        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="HashMap集合"><a href="#HashMap集合" class="headerlink" title="HashMap集合"></a>HashMap集合</h1><p>HashMap集合：</p><ol><li><p>HashMap集合底层是哈希表/散列表的数据结构。</p></li><li><p>哈希表是一个怎样的数据结构呢？</p></li></ol><p>​    哈希表是一个数组和单向链表的结合体。</p><p>​    数组：在查询方面效率很高，随机增删方面效率很低。</p><p>​    单向链表：在随机增删方面效率较高，在查询方面效率很低。</p><p>​    哈希表将以上的两种数据结构融合在一起，充分发挥它们各自的优点。</p><ol><li>HashMap集合底层的源代码：</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class HashMap{  // HashMap底层实际上就是一个数组。（一维数组）  Node&lt;K,V&gt;[] table;  // 静态的内部类HashMap.Node  static class Node&lt;K,V&gt; {    final int hash; // 哈希值（哈希值是key的hashCode()方法的执行结果。hash值通过哈希函数/算法，可以转换存储成数组的下标。）    final K key; // 存储到Map集合中的那个key    V value; // 存储到Map集合中的那个value    Node&lt;K,V&gt; next; // 下一个节点的内存地址。  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    哈希表/散列表：一维数组，这个数组中每一个元素是一个单向链表。（数组和链表的结合体。）</p><ol><li>最主要掌握的是：</li></ol><p>​    <code>map.put(k,v)</code></p><p>​    <code>v = map.get(k)</code></p><p>​    以上这两个方法的实现原理，是必须掌握的。</p><p><img src="https://cdn.jsdelivr.net/gh/DZ-O/CDN/img/image-20211112174942687.png" alt="image-20211112174942687"></p><ol><li>HashMap集合的key部分特点：</li></ol><p>​        无序，不可重复。</p><p>​        为什么无序？ 因为不一定挂到哪个单向链表上。</p><p>​        不可重复是怎么保证的？ equals方法来保证HashMap集合的key不可重复。</p><p>​        如果key重复了，value会覆盖。</p><p>​        放在HashMap集合key部分的元素其实就是放到HashSet集合中了。</p><p>​        所以HashSet集合中的元素也需要同时重写hashCode()+equals()方法。</p><ol><li>哈希表HashMap使用不当时无法发挥性能！</li></ol><p>​        假设将所有的hashCode()方法返回值固定为某个值，那么会导致底层哈希表变成了纯单向链表。这种情况我们成为：散列分布不均匀。</p><p>​        <strong><em>什么是散列分布均匀？</em></strong></p><p>​              假设有100个元素，10个单向链表，那么每个单向链表上有10个节点，这是最好的，是散列分布均匀的。</p><p>​        <strong><em>假设将所有的hashCode()方法返回值都设定为不一样的值，可以吗，有什么问题？</em></strong></p><p>​              不行，因为这样的话导致底层哈希表就成为一维数组了，没有链表的概念了。也是散列分布不均匀。</p><p>​        散列分布均匀需要你重写hashCode()方法时有一定的技巧。</p><ol><li><p>重点：放在HashMap集合key部分的元素，以及放在HashSet集合中的元素，需要同时重写hashCode和equals方法。</p><ol><li>HashMap集合的默认初始化容量是16，默认加载因子是0.75</li></ol></li></ol><p>​        这个默认加载因子是当HashMap集合底层数组的容量达到75%的时候，数组开始扩容。</p><blockquote><p>重点，记住：HashMap集合初始化容量必须是2的倍数，这也是官方推荐的， 这是因为达到散列均匀，为了提高HashMap集合的存取效率，所必须的。 </p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class HashMapTest01 {    public static void main(String[] args) {        // 测试HashMap集合key部分的元素特点        // Integer是key，它的hashCode和equals都重写了。        Map&lt;Integer,String&gt; map = new HashMap&lt;&gt;();        map.put(1111, "zhangsan");        map.put(6666, "lisi");        map.put(7777, "wangwu");        map.put(2222, "zhaoliu");        map.put(2222, "king"); //key重复的时候value会自动覆盖。        System.out.println(map.size()); // 4        // 遍历Map集合        Set&lt;Map.Entry&lt;Integer,String&gt;&gt; set = map.entrySet();        for(Map.Entry&lt;Integer,String&gt; entry : set){            // 验证结果：HashMap集合key部分元素：无序不可重复。            System.out.println(entry.getKey() + "=" + entry.getValue());        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong><em>HashMap集合key部分允许null吗？</em></strong></p><p>  允许,但是要注意：HashMap集合的key null值只能有一个。</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class HashMapTest03 {    public static void main(String[] args) {        Map map = new HashMap();        // HashMap集合允许key为null        map.put(null, null);        System.out.println(map.size()); // 1        // key重复的话value是覆盖！        map.put(null, 100);        System.out.println(map.size()); //1        // 通过key获取value        System.out.println(map.get(null)); // 100    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="Hashtable"><a href="#Hashtable" class="headerlink" title="Hashtable"></a>Hashtable</h1><p><strong><em>Hashtable的key可以为null吗？</em></strong></p><p>​    Hashtable的key和value都是不能为null的。</p><p>​    HashMap集合的key和value都是可以为null的。</p><p>Hashtable方法都带有synchronized：线程安全的。线程安全有其它的方案，这个Hashtable对线程的处理导致效率较低，使用较少了。</p><p>Hashtable和HashMap一样，底层都是哈希表数据结构。</p><p>Hashtable的初始化容量是11，默认加载因子是：0.75</p><p>Hashtable的扩容是：原容量 * 2 + 1</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class HashtableTest01 {    public static void main(String[] args) {        Map map = new Hashtable();//java.lang.Nul1PointerException        map.put(null, "123");        map.put(100, null);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="Properties属性类"><a href="#Properties属性类" class="headerlink" title="Properties属性类"></a>Properties属性类</h1><p>Properties是一个Map集合，继承Hashtable，Properties的key和value都是String类型。</p><p>Properties被称为属性类对象。</p><p>Properties是线程安全的。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class PropertiesTest01 {    public static void main(String[] args) {        // 创建一个Properties对象        Properties pro = new Properties();        // 需要掌握Properties的两个方法，一个存，一个取。        pro.setProperty("url", "jdbc:mysql://localhost:3306/bjpowernode");        pro.setProperty("driver","com.mysql.jdbc.Driver");        pro.setProperty("username", "root");        pro.setProperty("password", "123");        // 通过key获取value        String url = pro.getProperty("url");        String driver = pro.getProperty("driver");        String username = pro.getProperty("username");        String password = pro.getProperty("password");        System.out.println(url);        System.out.println(driver);        System.out.println(username);        System.out.println(password);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="TreeSet集合"><a href="#TreeSet集合" class="headerlink" title="TreeSet集合"></a>TreeSet集合</h1><p>TreeSet集合存储元素特点：</p><ol><li><p>无序不可重复的，但是存储的元素可以自动按照大小顺序排序！称为：可排序集合。</p></li><li><p>无序：这里的无序指的是存进去的顺序和取出来的顺序不同。并且没有下标。</p></li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class TreeSetTest01 {    public static void main(String[] args) {        // 创建集合对象        Set&lt;String&gt; strs = new TreeSet&lt;&gt;();        // 添加元素        strs.add("A");        strs.add("B");        strs.add("Z");        strs.add("Y");        strs.add("Z");        strs.add("K");        strs.add("M");        // 遍历        /*            A            B            K            M            Y            Z        从小到大自动排序！         */        for(String s : strs){            System.out.println(s);        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><ol><li><p>TreeSet集合底层实际上是一个TreeMap</p></li><li><p>TreeMap集合底层是一个二叉树。</p></li><li><p>放到TreeSet集合中的元素，等同于放到TreeMap集合key部分了。</p></li><li><p>TreeSet集合中的元素：无序不可重复，但是可以按照元素的大小顺序自动排序。称为：可排序集合。</p></li></ol></blockquote><h3 id="集合元素排序"><a href="#集合元素排序" class="headerlink" title="集合元素排序"></a>集合元素排序</h3><p><strong><em>对自定义的类型来说，TreeSet可以排序吗？</em></strong></p><p>  以下程序中对于Person类型来说，无法排序。因为没有指定Person对象之间的比较规则。谁大谁小并没有说明啊。</p><p> 以下程序运行的时候出现了这个异常：</p><p>​    <code>java.lang.ClassCastException:</code></p><p>​          <code>class com.bjpowernode.javase.collection.Person</code></p><p>​          <code>cannot be cast to class java.lang.Comparable</code></p><p>  出现这个异常的原因是Person类没有实现<code>java.lang.Comparable</code>接口。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class TreeSetTest03 {    public static void main(String[] args) {        Person p1 = new Person(32);        //System.out.println(p1);        Person p2 = new Person(20);        Person p3 = new Person(30);        Person p4 = new Person(25);        // 创建TreeSet集合        TreeSet&lt;Person&gt; persons = new TreeSet&lt;&gt;();        // 添加元素        persons.add(p1);        persons.add(p2);        persons.add(p3);        persons.add(p4);        // 遍历        for (Person p : persons){            System.out.println(p);        }    }}class Person {    int age;    public Person(int age){        this.age = age;    }    // 重写toString()方法    public String toString(){        return "Person[age="+age+"]";    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="实现Comparable接口实现自定义类型排序："><a href="#实现Comparable接口实现自定义类型排序：" class="headerlink" title="实现Comparable接口实现自定义类型排序："></a>实现Comparable接口实现自定义类型排序：</h3><p>自定义类型实现Comparable接口，并重写Comparable接口的compareTo方法，自定义排序规则。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.bjpowernode.javase.collection;import java.util.TreeSet;/*先按照年龄升序，如果年龄一样的再按照姓名升序。 */public class TreeSetTest05 {    public static void main(String[] args) {        TreeSet&lt;Vip&gt; vips = new TreeSet&lt;&gt;();        vips.add(new Vip("zhangsi", 20));        vips.add(new Vip("zhangsan", 20));        vips.add(new Vip("king", 18));        vips.add(new Vip("soft", 17));        for(Vip vip : vips){            System.out.println(vip);        }    }}class Vip implements Comparable&lt;Vip&gt;{    String name;    int age;    public Vip(String name, int age) {        this.name = name;        this.age = age;    }    @Override    public String toString() {        return "Vip{" +                "name='" + name + '\'' +                ", age=" + age +                '}';    }    /*    compareTo方法的返回值很重要：        返回0表示相同，value会覆盖。        返回&gt;0，会继续在右子树上找。【10 - 9 = 1 ，1 &gt; 0的说明左边这个数字比较大。所以在右子树上找。】        返回&lt;0，会继续在左子树上找。     */    @Override    public int compareTo(Vip v) {        // 写排序规则，按照什么进行比较。        if(this.age == v.age){            // 年龄相同时按照名字排序。            // 姓名是String类型，可以直接比。调用compareTo来完成比较。            return this.name.compareTo(v.name);        } else {            // 年龄不一样            return this.age - v.age;        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="使用比较器的方式"><a href="#使用比较器的方式" class="headerlink" title="使用比较器的方式"></a>使用比较器的方式</h3><p>单独在这里编写一个比较器,比较器实现<code>java.util.Comparator</code>接口。（Comparable是java.lang包下的。Comparator是java.util包下的。）</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.bjpowernode.javase.collection;import java.util.Comparator;import java.util.TreeSet;/*TreeSet集合中元素可排序的第二种方式：使用比较器的方式。*/public class TreeSetTest06 {    public static void main(String[] args) {        // 创建TreeSet集合的时候，需要使用这个比较器。        // TreeSet&lt;WuGui&gt; wuGuis = new TreeSet&lt;&gt;();//这样不行，没有通过构造方法传递一个比较器进去。        // 给构造方法传递一个比较器。        //TreeSet&lt;WuGui&gt; wuGuis = new TreeSet&lt;&gt;(new WuGuiComparator());        // 大家可以使用匿名内部类的方式（这个类没有名字。直接new接口。）        TreeSet&lt;WuGui&gt; wuGuis = new TreeSet&lt;&gt;(new Comparator&lt;WuGui&gt;() {            @Override            public int compare(WuGui o1, WuGui o2) {                return o1.age - o2.age;            }        });        wuGuis.add(new WuGui(1000));        wuGuis.add(new WuGui(800));        wuGuis.add(new WuGui(810));        for(WuGui wuGui : wuGuis){            System.out.println(wuGui);        }    }}// 乌龟class WuGui{    int age;    public WuGui(int age){        this.age = age;    }    @Override    public String toString() {        return "小乌龟[" +                "age=" + age +                ']';    }}// 单独在这里编写一个比较器// 比较器实现java.util.Comparator接口。（Comparable是java.lang包下的。Comparator是java.util包下的。）/*class WuGuiComparator implements Comparator&lt;WuGui&gt; {    @Override    public int compare(WuGui o1, WuGui o2) {        // 指定比较规则        // 按照年龄排序        return o1.age - o2.age;    }} */<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>最终的结论：<br>    放到TreeSet或者TreeMap集合key部分的元素要想做到排序,包括两种方式：</p><p>​        第一种：放在集合中的元素实现<code>java.lang.Comparable</code>接口。</p><p>​        第二种：在构造TreeSet或者TreeMap集合的时候给它传一个比较器对象。</p><p><strong><em>Comparable和Comparator怎么选择呢？</em></strong></p><p>​    当比较规则不会发生改变的时候，或者说当比较规则只有1个的时候，建议实现Comparable接口。</p><p>​    如果比较规则有多个，并且需要多个比较规则之间频繁切换，建议使用Comparator接口。</p><p>​    Comparator接口的设计符合<em>OCP</em>原则。</p></blockquote><h1 id="Collections集合工具类"><a href="#Collections集合工具类" class="headerlink" title="Collections集合工具类"></a>Collections集合工具类</h1><p><code>java.util.Collection</code> 集合接口</p><p><code>java.util.Collections</code> 集合工具类，方便集合的操作。</p><h3 id="常用方法：-1"><a href="#常用方法：-1" class="headerlink" title="常用方法："></a>常用方法：</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.bjpowernode.javase.collection;import java.util.*;/*java.util.Collection 集合接口java.util.Collections 集合工具类，方便集合的操作。 */public class CollectionsTest {    public static void main(String[] args) {        // ArrayList集合不是线程安全的。        List&lt;String&gt; list = new ArrayList&lt;&gt;();        // 变成线程安全的        Collections.synchronizedList(list);        // 排序        list.add("abf");        list.add("abx");        list.add("abc");        list.add("abe");        Collections.sort(list);        for(String s : list){            System.out.println(s);        }        List&lt;WuGui2&gt; wuGuis = new ArrayList&lt;&gt;();        wuGuis.add(new WuGui2(1000));        wuGuis.add(new WuGui2(8000));        wuGuis.add(new WuGui2(500));        // 注意：对List集合中元素排序，需要保证List集合中的元素实现了：Comparable接口。        Collections.sort(wuGuis);        for(WuGui2 wg : wuGuis){            System.out.println(wg);        }        // 对Set集合怎么排序呢？        Set&lt;String&gt; set = new HashSet&lt;&gt;();        set.add("king");        set.add("kingsoft");        set.add("king2");        set.add("king1");        // 将Set集合转换成List集合        List&lt;String&gt; myList = new ArrayList&lt;&gt;(set);        Collections.sort(myList);        for(String s : myList) {            System.out.println(s);        }        // 这种方式也可以排序。        //Collections.sort(list集合, 比较器对象);    }}class WuGui2 implements Comparable&lt;WuGui2&gt;{    int age;    public WuGui2(int age){        this.age = age;    }    @Override    public int compareTo(WuGui2 o) {        return this.age - o.age;    }    @Override    public String toString() {        return "WuGui2{" +                "age=" + age +                '}';    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java面向对象</title>
      <link href="/2021/10/13/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
      <url>/2021/10/13/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="面向对象基本概念"><a href="#面向对象基本概念" class="headerlink" title="面向对象基本概念"></a>面向对象基本概念</h1><p>​    面向对象编程（Object-Oriented Programming, OOP）</p><p>​    面向对象的本质就是：以类的方式组织代码，以对象的方式组织（封装）数据。</p><h2 id="如何建立面向对象的思维呢？"><a href="#如何建立面向对象的思维呢？" class="headerlink" title="如何建立面向对象的思维呢？"></a>如何建立面向对象的思维呢？</h2><blockquote><p>1、先整体，再局部</p><p>2、先抽象，再具体</p><p>3、能做什么，再怎么做</p></blockquote><h2 id="面向对象的三大核心特性："><a href="#面向对象的三大核心特性：" class="headerlink" title="面向对象的三大核心特性："></a><strong>面向对象的三大核心特性</strong>：</h2><blockquote><ul><li>可重用性：代码重复使用，减少代码量，提高开发效率。面向对象的三大基本特征（继承、封装和多态）都围绕这个核心。</li><li>可扩展性：指新的功能可以很容易地加入到系统中来，便于软件的修改。</li><li>客观理性：能够将功能与数据结合，方便管理。</li></ul></blockquote><h2 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a><strong>类与对象</strong></h2><p>​    类：类是一种分类，一个类别，一个模板，它描述一类对象的行为和状态，是一组具有相同特性（属性）与行为（方法）的事物集合</p><p>​    对象：是一个个性的产物，是一个个体的特征，是类的一个实例，有状态和行为</p><h3 id="类的定义："><a href="#类的定义：" class="headerlink" title="类的定义："></a>类的定义：</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class 类名{    //成员变量    //成员方法}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="对象的定义："><a href="#对象的定义：" class="headerlink" title="对象的定义："></a>对象的定义：</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">类名 对象名 = new 类名();<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>调用成员变量：</p><blockquote><p>对象名.成员变量；</p></blockquote><p>调用成员方法：</p><blockquote><p>对象名.方法名(参数列表);</p></blockquote><h1 id="Java内存划分"><a href="#Java内存划分" class="headerlink" title="Java内存划分"></a>Java内存划分</h1><p><img src="https://cdn.jsdelivr.net/gh/DZ-O/CDN/img/image-20211013202346664.png" alt="image-20211013202346664"></p><h1 id="对象与内存分析"><a href="#对象与内存分析" class="headerlink" title="对象与内存分析"></a><strong>对象与内存分析</strong></h1><p>new 关键字表示创建一个对象</p><p>new 关键字表示实例化对象</p><p>new 关键字表示申请内存空间</p><blockquote><p>注意：如果使用一个没有申请内存空间的对象，会报空指针异常：jav a.lang.NullPointerException</p></blockquote><p><img src="https://img2018.cnblogs.com/blog/1271254/201907/1271254-20190701151646307-720557642.png" alt="img"></p><p><img src="https://img2018.cnblogs.com/blog/1271254/201907/1271254-20190701151704225-1092668522.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/DZ-O/CDN/img/1271254-20190701151720669-482614134.png" alt="img"></p><p><img src="https://img2018.cnblogs.com/blog/1271254/201907/1271254-20190701151826479-1883206851.png" alt="img"></p><p><img src="https://img2018.cnblogs.com/blog/1271254/201907/1271254-20190701151851914-2071010506.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/DZ-O/CDN/img/1271254-20190701151911530-487663432.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/DZ-O/CDN/img/1271254-20190701151930815-1272400797.png" alt="img"></p><p><img src="https://img2018.cnblogs.com/blog/1271254/201907/1271254-20190701151949536-2066971696.png" alt="img"></p><blockquote><p>（1）new关键字：表示向内存申请空间，也表示实例化一个对象，创建一个对象。</p><p>（2）一个对象在内存中的大小，由该对象的所有属性所占的内存大小的总和。引用类型变量在32位系统上占4个字节，在64位系统上占8个字节。加上而        外的对象隐性数据所占的大小。</p><p>（3）相同的类型才可以赋值</p><p>（4）不同的引用，指向同一个对象，任何一个引用改变对象的值，其它引用都会反映出来。</p><p>（5）编程时要注意的问题，在确定不使用对象时，要尽早释放对象：引用=null</p><p>（6）当一个堆中的对象没有被任何引用变量所指向时，该对象会被JVM 的 GC 程序认为是垃圾对象，从而被回收</p></blockquote><h1 id="面向对象的三大特性："><a href="#面向对象的三大特性：" class="headerlink" title="面向对象的三大特性："></a>面向对象的三大特性：</h1><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><blockquote><p>​        封装(Encapsulation)是面向对象的三大特征之一，它指的是将对象的状态信息隐藏在对象内部，不允许外部程序直接访问对象内部信息，而是通过该类所提供的方法来实现对内部信息的操作和访问。</p><p>　　封装是面向对象编程语言对客观世界的模拟，在客观世界里，对象的状态信息都被隐藏在对象内部，外界无法直接操作和修改。比如说一个人的年龄，年龄只会随着时间的流逝而逐渐增长，不能随意修改人的年龄。对一个类或对象实现良好的封装，可以实现以下目的。</p><p>封装有：属性的封装、方法的封装、类的封装、组件的封装、模块化封装、系统级封装…</p><p>封装的好处：模块化、信息隐藏、代码重用、插件化易于调试、具有安全性</p><p>封装的缺点：会影响执行效率</p></blockquote><p>封装之前：属性都可以直接访问和修改</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Person{　　String name;　　int age;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>封装之后：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Person{　　//属性是成员变量，私有化属性，使得其他对象不能直接访问属性　　private String name;　　private int age;　　//参数及方法内定义的变量是局部变量　　public void setName(String name){　　this.name = name;}　　public String getName(){　　return name;}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a><strong>构造方法</strong></h2><blockquote><p>（1）构造方法名称与类名相同，没有返回值声明（包括 void）</p><p>（2）构造方法用于初始化数据（属性）</p><p>（3）每一个类中都会有一个默认的无参的构造方法</p><p>（4）如果类中有显示的构造方法，那么默认构造方法将无效</p><p>（5）如果有显示的构造方法，还想保留默认构造 方法，需要显示的写出来。</p><p>（6）构造方法可以有多个，但参数不一样，称为构造方法的重载</p><p>（7）在构造方法中调用另一个构造方法，使用this(…)，该句代码必须在第一句。</p><p>（8）构造方法之间的调用，必须要有出口。</p><p>（9）给对象初始化数据可以使用构造方法或setter方法，通常情况下，两者都会保留。</p><p>（10）一个好的编程习惯是要保留默认的构造方法。（为了方便一些框架代码使用反射来创建对象）</p><p>（11）private Dog(){}，构造方法私有化，当我们的需求是为了 保正该类只有一个对象时（单例模式就是私有化构造器）。</p></blockquote><p>无参构造方法：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public Dog(){    } //如果一个类没有定义构造方法，则默认无无参构造，如果有定义有参构造，最好再显示定义一个无参构造方法<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>带参构造方法：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public Dog(String name){this.name = name;}public Dog(String name,int age){this.name = name;this.age = age;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="值传递与引用传递？"><a href="#值传递与引用传递？" class="headerlink" title="值传递与引用传递？"></a><strong>值传递与引用传递？</strong></h2><blockquote><p><strong>首先，注意：在java中只有按值传递，并没有所谓的按引用传递</strong></p></blockquote><p>​    java数据类型可以分为两大类：基本类型（primitive types）和引用类型（reference types）</p><p><img src="https://cdn.jsdelivr.net/gh/DZ-O/CDN/img/1271254-20190701153202775-2050721336.png" alt="img"></p><ul><li>基本数据类型的按值传递</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Swap {public static void main(String[] args) {　　int x = 10;　　int y = 20;　　swap(x, y);　　System.out.println("x(2) = " + x);　　System.out.println("y(2) = " + y);}public static void swap(int x, int y) {　　int temp = x;　　x = y;　　y = temp;　　System.out.println("x(1) = " + x);　　System.out.println("y(1) = " + y);}}/*输出x(1) = 20y(1) = 10x(2) = 10y(2) = 20*/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    main函数调用swap函数来交换 x，y的值，然而调用函数之后发现main中x，y的值并未交换。包括在Java api中找不到一个可以交换两个变量的方法。这与Java语言的特性有关。通过一个图就可以知道上面程序的运行结果了。</p><p><img src="https://cdn.jsdelivr.net/gh/DZ-O/CDN/img/1271254-20190701153455043-1779820622.png" alt="img"></p><p>​    main函数中的x，y和swap函数中的x，y分别存放在不同的区域，在main中调用swap函数的时候，会将main中的x，y的值赋给swap中的x，y。当swap函数中对x，y交换时只是对swap帧中的x，y做交换，并不会改变main中的x，y。所以当函数返回时main中的x，y并不会改变.</p><ul><li>引用数据类型的按值传递</li></ul><p>引用数据数据类型分为三种：①接口 ②类 ③数组</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public static void main(String[] args) {　　int []a={10,20};　　System.out.println("a[0] :"a[0]+"a[1] : "+a[1]);//a[0]=10,a[1]=20;　　swap(a, 0, 1);　　System.out.println("a[0] :"a[0]+"a[1] : "+a[1]);//a[0]=20,a[1]=10;}public static void swap(int []a,int i,int j){　　nt temp=a[i];　　a[i]=a[j];　　a[j]=temp;　　System.out.println("a[0] :"a[0]+"a[1] : "+a[1]);//a[0]=20,a[1]=10;}//输出/*a[0]=10 a[1]=20a[0]=20 a[1]=10a[0]=20 a[1]=10*/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    运行程序后发现，swap函数对a[0] ,a[1]的操作竟然影响到了main函数中的a[0] ,a[1]的值，真是不可思议。为什么会产生如此之结果。<strong>原来引用类型的按值传递，传递的是对象的地址</strong></p><p><img src="https://cdn.jsdelivr.net/gh/DZ-O/CDN/img/1271254-20190701154246890-805492877.png" alt="img"></p><p>​    由图可以看出在swap中仅仅是得到了数组的地址，并没有对数组的元素进行复制，在swap中对数组的操作是直接对main函数中数组的操作，因此swap函数返回后main函数中的a[0] ,a[1]的值发生交换</p><blockquote><p><strong>参考</strong>：<a href="https://blog.csdn.net/u013309870/article/details/75499175">https://blog.csdn.net/u013309870/article/details/75499175</a></p></blockquote><h2 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a><strong>static关键字</strong></h2><blockquote><p>static关键字的作用：方便在没有创建对象的情况下来进行调用（方法/变量）。</p><p>​    a、使用static关键字修饰一个属性：声明为static的变量实质上就是全局变量</p><p>​    b、使用static关键字修饰一个方法：在一个类中定义一个方法为static，那就是说，无需本类的对象即可调用此方法（类调用）</p><p>​    c、使用static关键字修饰一个类（内部类）：</p><p>声明为static的方法有以下几条限制： </p><p>​    它们仅能调用其他的static 方法，反过来是可以的。 </p><p>​    它们只能访问static数据。 </p><p>​    它们不能以任何方式引用this或super。</p><p>​    不允许用来修饰局部变量</p></blockquote><p>​    一旦使用了<code>static</code>关键字，那么这样的内容将不再属于对象自己，而是属于类，所以凡是本类的对象，都共享一份</p><p><img src="https://cdn.jsdelivr.net/gh/DZ-O/CDN/img/image-20211013204500835.png" alt="image-20211013204500835"></p><p><img src="https://cdn.jsdelivr.net/gh/DZ-O/CDN/img/image-20211013204538802.png" alt="image-20211013204538802"></p><blockquote><p>注意：</p><ol><li>静态不能直接访问非静态。原因：应为在内存中是先有的静态内容，后有的非静态内容。“先人不知道后人，但是后人知道先人”</li><li>静态方法当中不能用this。原因：this代表的当前对象，通过谁调用的方法，谁就是当前对象</li></ol></blockquote><h3 id="静态代码块"><a href="#静态代码块" class="headerlink" title="静态代码块"></a>静态代码块</h3><p>静态代码块格式：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class 类名{    static {        //内容    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>特点：</p><p>​    当第一次用到本类时，静态代码块执行唯一的一次。静态内容总是优先于非静态，所以静态代码块比构造方法先执行。</p><p>用途：</p><p>​    用来一次性的对静态成员变量进行赋值。</p></blockquote><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>继承是面向对象三大特征之一</p><p>继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类</p><p>被继承的类称为父类（超类），继承父类的类称为子类（派生类）</p><p>通过继承可以实现代码重用</p><p>子类拥有父类非 private 的属性、方法。</p><p>子类可以拥有自己的属性和方法，即子类可以对父类进行扩展。</p><p>子类可以用自己的方式实现父类的方法。</p><p>构造器而言，它只能够被调用，而不能被继承，可以通过使用super()进行调用，</p><p>对于继承而已，子类会默认调用父类的构造器，但是如果没有默认的父类构造器，子类必须要显示的指定父类的构造器（通过super（）），而且必须是在子类构造器中做的第一件事(第一行代码)。</p><p>对于protected而言，它指明就类用户而言，他是private，但是对于任何继承与此类的子类而言或者其他任何位于同一个包的类而言，他却是可以访问的</p><p><code>Java 的继承是单继承，但是可以多重继承</code></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Dog{private String name;private String sex;public void eat(){System.out.println(“吃饭”);}}public class HomeDog extends Dog{　　//类的定义}public class HuskyDog extends Dog{　　//类的定义}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>继承的好处：</p><ul><li>提高代码的复用性</li><li>提高代码的维护性</li><li>让类与类之间产生关系，是多态的前提</li></ul><p>继承的缺点：</p><p>​    增强了类与类之间的耦合性</p></blockquote><h3 id="方法的重写"><a href="#方法的重写" class="headerlink" title="方法的重写"></a>方法的重写</h3><p>在Java中，子类可继承父类中的方法，而不需要重新编写相同的方法。但有时子类并不想原封不动地继承父类的方法，而是想做一定的修改，这就需要采用方法的重写。方法重写又称方法覆盖。</p><p>在子类和父类中，重写方法后，在调用时，以创建的对象类型为准，会调用谁的方法。</p><blockquote><p>重写特性：<br>    a、发生在子父类中，方法重写的两个方法返回值、方法名、参数列表必须完全一致（子类重写父类的方法）<br>    b、子类抛出的异常不能超过父类相应方法抛出的异常（子类异常不能大于父类异常）<br>    c、子类方法的访问级别不能低于父类相应方法的访问级别(子类访问级别不能低于父类访问级别)<br>    d、父类中的方法若使用private、static、final任意修饰符修饰，那么，不能被子类重写。</p></blockquote><h3 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a><strong>this关键字</strong></h3><p>this关键字指向的是当前对象的引用</p><p>调用类中的属性：this.属性名称，指的是访问类中的成员变量，用来区分成员变量和局部变量（重名问题）</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Student{    //成员变量    String name;    int age;    int classNum;    public Student(String name,int age,int classNum){            //s1调用了构造方法，所以这里的this代表s1对象        this.name = name; //成员变量name=局部变量name        this.age = age;        this.classNum = classNum;    }        public static void main(String[] args){        Student s1 = new Student("张三",18,1);        System.out.println(s1.name);//打印 张三    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>调用类中的方法：this.方法名称，用来访问本类的成员方法</p><p>调用类构造方法：this();访问本类的构造方法，()中可以有参数的 如果有参数 就是调用指定的有参构造</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Test1 {        public Test1(){        this("张三",18);    }    public Test1(String name,int age){        System.out.println("姓名："+name+"，年龄："+age);    }    public static void main(String[] args) {        Test1 test1 = new Test1();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>注意：</p><ol><li><p>this() 不能使用在普通方法中，只能写在构造方法中</p></li><li><p>必须是构造方法中的第一条语句</p></li></ol></blockquote><h3 id="super关键字"><a href="#super关键字" class="headerlink" title="super关键字"></a><strong>super关键字</strong></h3><p>可以理解为对父类的引用，使用super来调用父类的属性，方法，和构造方法</p><p>super可以完成以下的操作：</p><ol><li><p>使用super调用父类中的属性，可以从父类实例处获得信息。</p></li><li><p>使用super调用父类中的方法，可以委托父类对象帮助完成某件事情。</p></li><li>使用super调用父类中的构造方法（super(实参)形式），必须在子类构造方法的第一条语句，调用父类中相应的构造方法，若不显示的写出来，默认调用父类的    无参构造方法，比如：super();</li></ol><h3 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h3><p>使用final关键字完成以下的操作：</p><ul><li>使用final关键字声明一个常量<br>当final修饰一个基本数据类型时，表示该基本数据类型的值一旦在初始化后便不能发生变化；如果final修饰一个引用类型时，则在对其初始化之后便不能再让其指向其他对象了，但该引用所指向的对象的内容是可以发生变化的</li><li>使用final关键字声明一个方法,该方法为最终方法，且只能被子类继承，但是不能被子类重写。</li><li>使用final关键字声明一个类,该类就转变为最终类，没有子类的类，fianl修饰的类无法被继承。</li><li>在方法参数中使用final，在该方法内部不能修改参数的值（在内部类中详解）</li></ul><p>当final变量是基本数据类型以及String类型时，如果在编译期间能知道它的确切值，则编译器会把它当做编译期常量使用，不过要注意，只有在编译期间能确切知道final变量值的情况下，编译器才会进行这样的优化</p><p>引用变量被final修饰之后，虽然不能再指向其他对象，但是它指向的对象的内容是可变的。</p><p><img src="https://cdn.jsdelivr.net/gh/DZ-O/CDN/img/image-20211013210801232.png" alt="image-20211013210801232"></p><p><img src="https://cdn.jsdelivr.net/gh/DZ-O/CDN/img/image-20211013210813736.png" alt="image-20211013210813736"></p><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>​    即同一个方法可以根据发送对象的不同而采用多种不同的行为方式。</p><p>​    一个对象的实际类型是确定的，但是可以只想对象的用用的类型有多种。</p><p>多态存在的先天条件：</p><pre><code>           1. 有继承关系           2. 子类重写父类方法           3. 父类引用指向子类对象</code></pre><blockquote><p>注意：多态是方法的多态，属性没有多态</p></blockquote><p>多态基本格式：</p><blockquote><p>父类名 对象名 = new 子类名称();</p><p>or</p><p>接口名 对象名 = new 实现类名称();</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Demo01Multi {    public static void main(String[] args){        //左侧父类的引用，指向了右侧子类的对象        Fu obj = new Zi()    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/DZ-O/CDN/img/image-20211013211226566.png" alt="image-20211013211226566"></p><p>访问成员变量的两种方式：</p><ol><li>直接通过对象名称访问成员变量，看等号左边是谁，优先用谁，没有则向上找</li><li>间接通过成员方法访问成员变量，看该方法属于谁，就先用谁的，没有则向上找</li></ol><p>在多态的代码中，成员方法的访问规则是：</p><p>​    看new的是谁的，就优先用谁的，没有则向上找</p><blockquote><p>口诀：编译看左边，运行看右边</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/DZ-O/CDN/img/image-20211013211623557.png" alt="image-20211013211623557"></p><p>对比成员变量和方法：</p><blockquote><p>成员变量：编译看左边，运行还是看左边</p><p>成员方法：编译看左边，运行看右边</p></blockquote><h3 id="向上下转型："><a href="#向上下转型：" class="headerlink" title="向上下转型："></a>向上下转型：</h3><p><img src="https://cdn.jsdelivr.net/gh/DZ-O/CDN/img/image-20211013211830845.png" alt="image-20211013211830845"></p><p><img src="https://cdn.jsdelivr.net/gh/DZ-O/CDN/img/image-20211013211853746.png" alt="image-20211013211853746"></p><p>向上转型：将子类实例转为父类引用<br>    格式：父类 父类对象 = 子类实例 ； 自动转换</p><p>以基本数据类型操作为例：int i = ‘a’ ;</p><p>（因为char的容量比int小，所以可以自动完成）</p><p>向下转型：将父类实例转为子类实例<br>    格式：子类 子类对象 = （子类）父类实例 ；强制转换<br>以基本数据类型操作为例：char c = (char)97;</p><p>因为整型是4个字节比char 2个字节要大，所以需要强制完成</p><blockquote><p>a、方法的重载与重写就是方法的多态性表现<br>b、多个子类就是父类中的多种形态<br>c、父类引用可以指向子类对象，自动转换<br>d、子类对象指向父类引用需要强制转换（注意：类型不对会报异常）<br>e、在实际开发中尽量使用父类引用（更利于扩展）</p></blockquote><p>指向子类的父类引用由于向上转型了，它只能访问父类中拥有的方法和属性，而对于子类中存在而父类中不存在的方法，<br>该引用是不能使用的，尽管是重载该方法。若子类重写了父类中的某些方法，在调用该些方法的时候，<br>必定是使用子类中定义的这些方法（动态连接、动态调用）。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class A{　　void fun1(){}　　void fun2(){}}class B extends A{　　void fun1(String a){} //重载fun1　　void fun2(){} //重写fun2}class C{　　public static void main(String[] args){　　A a = new B();　　a.fun1(); //这里会调用A类的fun1方法，由于向上转型，B的fun1(String a) 会被丢弃　　a.fun2(); //这里调用B的fun2方法，由于是new 的B对象，而B重写了fun2，所以会调用B的fun2}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="instanceof-关键字"><a href="#instanceof-关键字" class="headerlink" title="instanceof 关键字"></a>instanceof 关键字</h3><p><img src="https://cdn.jsdelivr.net/gh/DZ-O/CDN/img/image-20211013212213006.png" alt="image-20211013212213006"></p><p>该语句一般用于判断一个对象是否为某个类的实例，是返回true，否返回false</p><p>父类的设计法则<br>    通过instanceof关键字，我们可以很方便的检查对象的类型，但如果一个父类的子类过多，这样的判断还是显得很繁琐，那么如何去设计一个父类呢？<br>        a、父类通常情况下都设计为抽象类或接口，其中优先考虑接口，如接口不能满足才考虑抽象类。</p><p>​        <em>b、一个具体的类尽可能不去继承另一个具体类，这样的好处是无需检查对象是否为父类的对象。</em></p><h1 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h1><p>内部类就是在一个类的内部定义的类。</p><p>成员内部类：内部类对象依赖外部类对象而存在，即在创建一个普通内部类对象时首先需要创建其外部类对象</p><p>内部类对象可以访问外部类对象中所有访问权限的字段，同时，外部类对象也可以通过内部类的对象引用来访问内部类中定义的所有访问权限的字段</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Outer {　　class Inner{}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>编译上述代码会产生两个文件：Outer.class和Outer$Inner.class。</p><p>在外部创建内部类对象</p><p>内部类除了可以在外部类中产生实例化对象，也可以在外部类的外部来实例化。</p><p>那么，根据内部类生成的*.class文件：OuterInner.class“Inner.class“” 符号在程序运行时将替换成“.”</p><p>所以内部类的访问：通过“外部类.内部类”的形式表示。</p><p>内部类实例化对象：</p><p>​    外部类.内部类 内部类对象 = new 外部类().new 内部类();</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">Outer out = new Outer() ;// 产生外部类实例Outer.Inner in = null; // 声明内部类对象in = out.new Inner() ; // 实例化内部类对象<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="局部内部类："><a href="#局部内部类：" class="headerlink" title="局部内部类："></a>局部内部类：</h3><p>内部类可以作为一个类的成员外，还可以把类放在方法内定义（不常用，匿名内部类可以显示局部内部类的功能）。</p><p>在局部内部类里面可以访问外部类对象的所有访问权限的字段，而外部类却不能访问局部内部类中定义的字段</p><blockquote><p>注意：<br>    a、局部内部类只能在定义该内部类的方法内实例化，不可以在此方法外对其实例化。</p><p>​    b、局部内部类对象不能使用该内部类所在方法的非final局部变量。</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Outer {　　public void doSomething(){　　class Inner{　　　　public void seeOuter(){}　　}　　}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类:"></a>静态内部类:</h3><p>​    在一个类内部定义一个静态内部类：</p><blockquote><p>注意：static定义的不管是类或方法只能访问static成员，所以static定义的内部类只能访问外部类当中的static属性或者方法。</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Outer{　　static class Inner{}}class Test {　　public static void main(String[] args){　　Outer.Inner n = new Outer.Inner();}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个时候Inner内是一个独立的类，如果此时想要实例化Inner类对象，只需要根据“外部类.内部类”的结构实例化对象</p><p>​    外部内.内部类 内部类对象 = new 外部类.内部类();</p><h3 id="匿名内部类："><a href="#匿名内部类：" class="headerlink" title="匿名内部类："></a>匿名内部类：</h3><p>匿名内部类就是没有名字的内部类。</p><p>匿名内部类的三种情况：<br>（1）继承式的匿名内部类<br>（2）接口式的匿名内部类<br>（3）参数式的匿名内部类</p><p>在使用匿名内部类时，要记住以下几个原则：<br>（1）不能有构造方法，只能有一个实例。<br>（2）不能定义任何静态成员、静态方法。<br>（3）不能是public,protected,private,static。<br>（4）一定是在new的后面，用其隐含实现一个接口或继承一个类。<br>（5）匿名内部类为局部的，所以局部内部类的所有限制都对其生效</p><p>​    有时候为了更加方便的体现出匿名内部类的使用，往往可以使用静态方法做一个匿名内部类的实现</p><p><img src="https://cdn.jsdelivr.net/gh/DZ-O/CDN/img/image-20211013213811174.png" alt="image-20211013213811174"></p><p>与内部类相比，匿名内部类只是一个没有名字的这能使用一次的，并且结构固定的子类</p><p>内部类的作用：</p><p>每个内部类都能独立地继承自一个（接口的）实现，所以无论外部类是否已经继承了某个（接口的）实现，对于内部类都没有影响。如果没有内部类提供的可以继承多个具体的或抽象的类的能力，一些设计与编程问题就很难解决。从这个角度看，内部类使得多重继承的解决方案变得完整。接口解决了部分问题，而内部类有效地实现了“多重继承”。</p><p>依赖外部类对象的：成员内部类，方法内部类，匿名内部类</p><p>静态内部类不依赖外部类的对象。所以，我们在项目中优先考虑选择静态内部类（不会产生内存泄露）</p>]]></content>
      
      
      <categories>
          
          <category> JavaSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于Django的个人博客</title>
      <link href="/2021/10/05/DjiangoBlog/"/>
      <url>/2021/10/05/DjiangoBlog/</url>
      
        <content type="html"><![CDATA[<h1 id="基于Django的个人博客项目使用"><a href="#基于Django的个人博客项目使用" class="headerlink" title="基于Django的个人博客项目使用"></a>基于Django的个人博客项目使用</h1><blockquote><p> 基于Django的个人博客，前端方面比较普通，没有用什么框架，所以看着比较随意。</p><p>项目地址：<a href="https://github.com/DZ-O/DjangoBlog">https://github.com/DZ-O/DjangoBlog</a></p></blockquote><h2 id="模型层"><a href="#模型层" class="headerlink" title="模型层"></a>模型层</h2><p>​    由于，Django自带的orm语法，使得我们可以不用书写SQL语句也能操作数据库，并且不用事先创建好数据库，只需要在项目应用目录下的models.py中写下每张表所对用的类，而类中的属性则是表中的字段。可根据需要自行修改，代码：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import timefrom django.db import models# Create your models here.class Article(models.Model):    # 文章表    title = models.CharField(max_length=64, verbose_name='文章标题')    content = models.TextField(verbose_name='文章内容')    create_time = models.DateTimeField(verbose_name='创建时间', auto_now_add=True)    revise_time = models.DateTimeField(verbose_name='修改时间', auto_now=True)    like_count = models.IntegerField(default=0,verbose_name='点赞数')    article_types = models.ForeignKey(to='ArticleType')    introduction = models.CharField(max_length=250,verbose_name='文章简介',default='这是一段简介')   # 文章与文章标签多对多关系通过第三张表Article2ArticleTag建立链接    # 这是半自动创建多对多表关系方式，方便拓展。第三张表的类需要自己手动写。    # 也可以直接使用，自动多对多关系，就不需要手动创建第三张表    article_Tag = models.ManyToManyField(to='ArticleTag',                                         through='Article2ArticleTag',                                         through_fields=('article', 'article_tag')                                         )# 文章分类表class ArticleType(models.Model):    types = models.CharField(max_length=32, verbose_name='文章分类')  # 日常、技术、分享.....# 文章标签表class ArticleTag(models.Model):    tag = models.CharField(max_length=32, verbose_name='文章标签')  # java、pyhon.....# 文章留言表class Message(models.Model):    user = models.CharField(max_length=10, verbose_name='留言人')    message_content = models.CharField(max_length=255, verbose_name='留言')    message_create_time = models.DateTimeField(verbose_name='创建时间', auto_now_add=True)    article = models.ForeignKey(to='Article')# 文章与文章标签多对多关系表class Article2ArticleTag(models.Model):    article = models.ForeignKey(to='Article')    article_tag = models.ForeignKey(to='ArticleTag')# 显示在首页的个人目标，可以不写，在首页的页面写死class Target(models.Model):    target = models.CharField(max_length=100, verbose_name='目标')# 显示在首页的文本句子，可以不写，在首页的页面写死class Text(models.Model):    text = models.CharField(max_length=100, verbose_name='文本')# 首页留言表，这里偷了懒，直接新起了一个表，可以修改文章留言表，就不用创建这张表class HomeMessage(models.Model):    home_message = models.CharField(max_length=100, verbose_name='首页留言')    home_article = models.CharField(max_length=10, verbose_name='作者')    creat_time = models.DateTimeField(verbose_name='留言时间', auto_now_add=True, )<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    表模型文件创建完毕后，此时的系统是没有对应的数据库的，需要我们只需数据库迁移命令，在此之前，记得修改项目的<code>settings.py</code>文件中的<code>DATABASES</code>中的内容为自己的数据库配置，</p><p><img src="https://cdn.jsdelivr.net/gh/DZ-O/CDN/img/image-20211006004633739.png" alt="image-20211006004633739"></p><p>​    如果数据库使用的是MySQL则在项目中的任意<code>__init.py__</code>文件下加入如下内容,:</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import pymysqlpymysql.install_as_MySQLdb()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​    项目根目录下的控制台执行数据库迁移命令：</p><blockquote><p>python <a href="http://manage.py/">manage.py</a> makemigrations</p><p>python <a href="http://manage.py/">manage.py</a> migrate</p></blockquote><p>​    执行完毕后你的数据库下将会出现如下几张表：</p><p><img src="https://cdn.jsdelivr.net/gh/DZ-O/CDN/img/image-20211006004519973.png" alt="image-20211006004519973"></p><h2 id="用户登录及后台管理问题"><a href="#用户登录及后台管理问题" class="headerlink" title="用户登录及后台管理问题"></a>用户登录及后台管理问题</h2><blockquote><p>这里有人就发现，我们模型层并没有创建用户类，怎么实现登陆到后台，对自己文章进行发布和管理呢？</p></blockquote><p>​    在这里我们使用Django的Auth模块，他会自动帮我们创建user表。而这个user表中的用户就是Django默认自带的路由<code>admin/</code>登录页面中所需要验证的用户，其中user表中的超级用户既可以登录到admin后台。</p><p>超级用户创建命令：</p><blockquote><p>python3 manage.py createsuperuser</p></blockquote><p>​    而这个后台页面，是Django自动生成的，在这里我们可对数据库进行可视化操作。前提是在配置文件中将数据库注册进去。</p><p><img src="https://cdn.jsdelivr.net/gh/DZ-O/CDN/img/image-20211006005526886.png" alt="image-20211006005526886"></p><p>​    当然，这个后台页面肯定不是我们需要的，这里我自己手动搭建了一个后台页面，老样子界面依旧简陋：</p><p><img src="https://cdn.jsdelivr.net/gh/DZ-O/CDN/img/image-20211006005952683.png" alt="image-20211006005952683"></p><p>​    在这里，就能够对文章进行发布及管理等操作了。</p><p>​    当然登录后台的url路由地址也不是使用的Django自动生成admin页面，这里我也自己新建了一个页面：</p><p><img src="https://cdn.jsdelivr.net/gh/DZ-O/CDN/img/image-20211006010313354.png" alt="image-20211006010313354"></p><p>​    验证码这一块，我并没有使用画图模块之类的，偷了个懒，使用的是smtplib模块，使用QQ邮箱发送随机验证码邮件到手上，修改<code>app01/views.py</code>下大概314行左右代码：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">code += tmp   # 随机验证码在登陆的视图函数里面需要用到 要比对 所以要找地方存起来并且其他视图函数也能拿到   request.session['code'] = code   email_from = "@qq.com"  # 改为自己的发送邮箱   email_to = "@qq.com"  # 接收邮箱   hostname = "smtp.qq.com"  # 不变，QQ邮箱的smtp服务器地址   login = "@qq.com"  # 发送邮箱的用户名   password = ""  # 发送邮箱的密码，即开启smtp服务得到的授权码。注：不是QQ密码。   subject = "贝克街验证码"  # 邮件主题   text = "贝克街验证码:" + code  # 邮件正文内容   smtp = SMTP_SSL(hostname)  # SMTP_SSL默认使用465端口   smtp.login(login, password)   msg = MIMEText(text, "plain", "utf-8")   msg["Subject"] = Header(subject, "utf-8")   msg["from"] = email_from   msg["to"] = email_to   smtp.sendmail(email_from, email_to, msg.as_string())   smtp.quit()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="静态资源收集"><a href="#静态资源收集" class="headerlink" title="静态资源收集"></a>静态资源收集</h2><p>​    项目部署在服务器之前，记得执行项目的静态资源文件收集操作，否则可能会出现静态资源无法访问现象，参考博客：<a href="https://blog.csdn.net/BGONE/article/details/91410220">django项目收集静态文件</a></p>]]></content>
      
      
      <categories>
          
          <category> 后端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Django </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
